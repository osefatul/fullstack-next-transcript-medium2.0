/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["sanity-nextmedium_node_modules_sanity_groq-store_dist_browser_groq-store_js"],{

/***/ "../sanity-nextmedium/node_modules/@sanity/groq-store/dist/browser/groq-store.js":
/*!***************************************************************************************!*\
  !*** ../sanity-nextmedium/node_modules/@sanity/groq-store/dist/browser/groq-store.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("function e(e){return e&&\"object\"==typeof e&&\"default\"in e?e.default:e}var r=e(__webpack_require__(/*! groq */ \"../sanity-nextmedium/node_modules/groq/lib/groq.js\")),t=e(__webpack_require__(/*! fast-deep-equal */ \"../sanity-nextmedium/node_modules/fast-deep-equal/index.js\")),n=__webpack_require__(/*! throttle-debounce */ \"../sanity-nextmedium/node_modules/throttle-debounce/cjs/index.js\"),o=__webpack_require__(/*! groq-js */ \"../sanity-nextmedium/node_modules/@sanity/groq-store/node_modules/groq-js/dist/groq-js.esm.js\"),i=__webpack_require__(/*! mendoza */ \"../sanity-nextmedium/node_modules/mendoza/lib/esm/index.js\");function u(){return(u=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}function s(e,r,t){var n,o=r.token,i=new e(\"https://\"+r.projectId+\".api.sanity.io/v1/data/listen/\"+r.dataset+\"?query=*&effectFormat=mendoza\",{withCredentials:!0,headers:o?{Authorization:\"Bearer \"+o}:void 0});return i.addEventListener(\"welcome\",t.open,!1),i.addEventListener(\"mutation\",(n=t.next,function(e){var r;try{r=JSON.parse(e.data)}catch(e){return}n(r)}),!1),i.addEventListener(\"channelError\",function(e){var r;i.close();try{r=JSON.parse(e.data)}catch(e){return void t.error(new Error(\"Unknown error parsing listener message\"))}t.error(new Error(r.message||r.error||\"Listener returned HTTP \"+r.statusCode))},!1),i.addEventListener(\"error\",function(e){var r=\"undefined\"!=typeof window&&window.location.origin,n=r?\", and that the CORS-origin (\"+r+\") is allowed\":\"\",o=function(e){return\"object\"==typeof e&&null!==e&&\"message\"in e}(e)?\" (\"+e.message+\")\":\"\";t.error(new Error(\"Error establishing listener - check that the project ID and dataset are correct\"+n+o))},!1),{unsubscribe:function(){return Promise.resolve(i.close())}}}function c(e){return e._id.startsWith(\"drafts.\")?e._id.slice(7):e._id}function a(e,r){var t=u({},e);return delete t._rev,i.applyPatch(t,r)}function f(){return Promise.resolve()}function d(){var e,r,t=(e=[\"*[_id == $id][0]\"],r||(r=e.slice(0)),e.raw=r,e);return d=function(){return t},t}function v(e,r,t){if(!e.s){if(t instanceof l){if(!t.s)return void(t.o=v.bind(null,e,r));1&r&&(r=t.s),t=t.v}if(t&&t.then)return void t.then(v.bind(null,e,r),v.bind(null,e,2));e.s=r,e.v=t;var n=e.o;n&&n(e)}}var l=function(){function e(){}return e.prototype.then=function(r,t){var n=new e,o=this.s;if(o){var i=1&o?r:t;if(i){try{v(n,1,i(this.v))}catch(e){v(n,2,e)}return n}return this}return this.o=function(e){try{var o=e.v;1&e.s?v(n,1,r?r(o):o):t?v(n,1,t(o)):v(n,2,o)}catch(e){v(n,2,e)}},n},e}();function h(e){return e instanceof l&&1&e.s}var m=function(e){var r=e.projectId,t=e.dataset,n=e.token,o=e.documentLimit;try{return Promise.resolve(fetch(\"https://\"+r+\".api.sanity.io/v1/data/export/\"+t,{credentials:\"include\",headers:n?{Authorization:\"Bearer \"+n}:void 0})).then(function(e){function r(r){var t,n,i=function(e){if(!e)throw new Error(\"Failed to read body from response\");var r,t=!1;function n(){t=!0,r&&r.cancel()}return new ReadableStream({start:function(o){r=e.getReader();var i=new TextDecoder,u=\"\";r.read().then(function e(s){try{if(s.done)return t?Promise.resolve():0===(u=u.trim()).length?(o.close(),Promise.resolve()):(o.enqueue(JSON.parse(u)),o.close(),Promise.resolve());for(var c=(u+=i.decode(s.value,{stream:!0})).split(\"\\n\"),a=0;a<c.length-1;++a){var f=c[a].trim();if(0===f.length)return Promise.resolve();try{o.enqueue(JSON.parse(f))}catch(e){return o.error(e),n(),Promise.resolve()}}if(u=c[c.length-1],!r)return Promise.resolve();var d=function(t,n){try{var o=Promise.resolve(r.read()).then(function(r){e(r)})}catch(e){return n(e)}return o&&o.then?o.then(void 0,n):o}(0,function(e){o.error(e)});return Promise.resolve(d&&d.then?d.then(function(){}):void 0)}catch(e){return Promise.reject(e)}}).catch(function(e){return o.error(e)})},cancel:n})}(e.body).getReader(),u=[],s=function(e,r){var t;do{var n=e();if(n&&n.then){if(!h(n)){t=!0;break}n=n.v}var o=r();if(h(o)&&(o=o.v),!o)return n}while(!o.then);var i=new l,u=v.bind(null,i,2);return(t?n.then(s):o.then(c)).then(void 0,u),i;function s(t){for(n=t;h(o=r())&&(o=o.v),o;){if(o.then)return void o.then(c).then(void 0,u);if((n=e())&&n.then){if(!h(n))return void n.then(s).then(void 0,u);n=n.v}}v(i,1,n)}function c(t){if(t){do{if((n=e())&&n.then){if(!h(n))return void n.then(s).then(void 0,u);n=n.v}if(h(t=r())&&(t=t.v),!t)return void v(i,1,n)}while(!t.then);t.then(c).then(void 0,u)}else v(i,1,n)}}(function(){return Promise.resolve(i.read()).then(function(e){if(function(e){return!!e&&\"error\"in e&&\"object\"==typeof e.error&&null!==e.error&&\"description\"in e.error&&\"string\"==typeof e.error.description&&!(\"_id\"in e)}(n=(t=e).value))throw new Error(\"Error streaming dataset: \"+n.error);if(n&&!n._id.startsWith(\"_.\")&&u.push(n),o&&u.length>o)throw i.cancel(\"Reached document limit\"),new Error(\"Error streaming dataset: Reached limit of \"+o+\" documents\")})},function(){return!t.done});return s&&s.then?s.then(function(e){return u}):u}var t=function(){if(200!==e.status)return Promise.resolve(e.json()).then(function(e){throw new Error(\"Error streaming dataset: \"+(\"object\"==typeof(r=e)&&\"error\"in r&&\"message\"in r?r.message||r.error:\"<unknown error>\"));var r})}();return t&&t.then?t.then(r):r()})}catch(e){return Promise.reject(e)}};exports.groq=r,exports.groqStore=function(e){if(function(){var e=[\"EventSource\",\"ReadableStream\",\"fetch\"].filter(function(e){return!(e in window)});if(e.length>0)throw new Error(\"Browser not supported. Missing browser APIs: \"+e.join(\", \"))}(),e.token)throw new Error(\"`token` option not currently supported in browser\");return function(e,i){var v,l=function(e,r){try{return Promise.resolve(h()).then(function(){var t=o.parse(e,{params:r});return Promise.resolve(o.evaluate(t,{dataset:m,params:r})).then(function(e){return e.get()})})}catch(e){return Promise.reject(e)}},h=function(){try{return v||(v=function(e,r,t){var n=t.getDocuments,o=t.EventSource,i=e.projectId,d=e.dataset,v=e.overlayDrafts,l=e.documentLimit;if(!e.listen)return{unsubscribe:f,loaded:n({projectId:i,dataset:d,documentLimit:l}).then(j).then(f)};var h,m,p,w,b,g,y=new Map,P=[],E=new Promise(function(e,r){m=e,p=r});return{unsubscribe:s(o,e,{next:function(e){h?(function(e){if(e.effects&&!e.documentId.startsWith(\"_.\")){var r=y.get(e.documentId)||null;!function(e,r){var t=y.get(e),n=h||[],o=t?n.indexOf(t):-1;-1===o&&r?(n.push(r),y.set(e,r)):r?(n.splice(o,1,r),y.set(e,r)):(n.splice(o,1),y.delete(e))}(e.documentId,a(r,e.effects.apply))}}(e),function(e,r){clearTimeout(g),b!==r.transactionId&&w?(j(w),b=void 0):(b=r.transactionId,w=e.slice()),g=setTimeout(j,25,e.slice())}(h,e)):P.push(e)},open:function(){try{return Promise.resolve(n({projectId:i,dataset:d,documentLimit:l})).then(function(e){(h=function(e,r){var t=new Map;return r.forEach(function(e){var r=t.get(e.documentId)||[];r.push(e),t.set(e.documentId,r)}),t.forEach(function(r,t){var n=e.find(function(e){return e._id===t});if(n){var o=!1,i=n;r.forEach(function(e){(o=o||e.previousRev===n._rev)&&e.effects&&(i=a(i,e.effects.apply))}),e.splice(e.indexOf(n),1,i)}else console.warn(\"Received mutation for missing document %s\",t)}),e}(e,P)).forEach(function(e){return y.set(e._id,e)}),j(h),m()})}catch(e){return Promise.reject(e)}},error:function(e){return p(e)}}).unsubscribe,loaded:E};function j(e){w=void 0,g=void 0,b=void 0,r(v?function(e){var r=new Map;return e.forEach(function(e){var t=r.get(c(e));e._id.startsWith(\"drafts.\")?r.set(c(e),function(e){return u({},e,{_id:c(e)})}(e)):t||r.set(e._id,e)}),Array.from(r.values())}(e):e)}}(e,function(e){m=e,p()},i)),Promise.resolve(v.loaded).then(function(){})}catch(e){return Promise.reject(e)}},m=[],p=n.throttle(e.subscriptionThrottleMs||50,function(){w.forEach(b)}),w=[];function b(e){return l(e.query,e.params).then(function(r){\"previousResult\"in e&&t(e.previousResult,r)||(e.previousResult=r,e.callback(void 0,r))}).catch(function(r){e.callback(r)})}return{query:l,getDocument:function(e){try{return Promise.resolve(h()).then(function(){return l(r(d()),{id:e})})}catch(e){return Promise.reject(e)}},getDocuments:function(e){try{return Promise.resolve(h()).then(function(){var r=e.map(function(e){return'*[_id == \"'+e+'\"][0]'}).join(\",\\n\");return l(\"[\"+r+\"]\")})}catch(e){return Promise.reject(e)}},subscribe:function(r,t,n){if(!e.listen)throw new Error(\"Cannot use `subscribe()` without `listen: true`\");var o={query:r,params:t,callback:n};w.push(o);var i=!1;return b(o),{unsubscribe:function(){return i||(i=!0,w.splice(w.indexOf(o),1)),Promise.resolve()}}},close:function(){return p.cancel(),v?v.unsubscribe():Promise.resolve()}}}(e,{EventSource:window.EventSource,getDocuments:m})};\n//# sourceMappingURL=groq-store.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZ3JvcS1zdG9yZS9kaXN0L2Jyb3dzZXIvZ3JvcS1zdG9yZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLHdEQUF3RCxRQUFRLG1CQUFPLENBQUMsZ0VBQU0sT0FBTyxtQkFBTyxDQUFDLG1GQUFpQixLQUFLLG1CQUFPLENBQUMsMkZBQW1CLElBQUksbUJBQU8sQ0FBQyw4R0FBUyxJQUFJLG1CQUFPLENBQUMsMkVBQVMsRUFBRSxhQUFhLG9DQUFvQyxZQUFZLG1CQUFtQixLQUFLLG1CQUFtQixzRUFBc0UsU0FBUyx3QkFBd0Isa0JBQWtCLDJIQUEySCw4QkFBOEIsMEJBQTBCLFFBQVEsRUFBRSxtR0FBbUcsTUFBTSxJQUFJLHFCQUFxQixTQUFTLE9BQU8sS0FBSyxvREFBb0QsTUFBTSxVQUFVLElBQUkscUJBQXFCLFNBQVMseUVBQXlFLCtFQUErRSw0Q0FBNEMsOEhBQThILGtEQUFrRCwwQkFBMEIsMEdBQTBHLE1BQU0sdUJBQXVCLG9DQUFvQyxjQUFjLHdEQUF3RCxnQkFBZ0IsVUFBVSxJQUFJLHVDQUF1QyxhQUFhLHlCQUF5QixhQUFhLCtEQUErRCxvQkFBb0IsU0FBUyxHQUFHLGtCQUFrQixTQUFTLG1CQUFtQiwwQ0FBMEMsbUJBQW1CLG1FQUFtRSxZQUFZLFVBQVUsU0FBUyxpQkFBaUIsY0FBYyxzQ0FBc0MscUJBQXFCLE1BQU0sY0FBYyxNQUFNLElBQUksaUJBQWlCLFNBQVMsU0FBUyxTQUFTLFlBQVksMEJBQTBCLElBQUksVUFBVSw2Q0FBNkMsU0FBUyxVQUFVLEdBQUcsR0FBRyxHQUFHLGNBQWMsNkJBQTZCLGtCQUFrQiwwREFBMEQsSUFBSSw4RUFBOEUsaUNBQWlDLDBCQUEwQixRQUFRLG9CQUFvQixjQUFjLHNCQUFzQiwyREFBMkQsV0FBVyxhQUFhLG1CQUFtQiwyQkFBMkIsa0JBQWtCLGdCQUFnQiwyQkFBMkIsNEJBQTRCLElBQUksa0pBQWtKLGdDQUFnQyxVQUFVLG1CQUFtQixhQUFhLEtBQUssa0JBQWtCLHlDQUF5QyxJQUFJLHlCQUF5QixTQUFTLHlDQUF5QywrQ0FBK0Msb0JBQW9CLElBQUksaURBQWlELEtBQUssRUFBRSxTQUFTLFlBQVksb0NBQW9DLGVBQWUsV0FBVyxFQUFFLG9EQUFvRCxVQUFVLFNBQVMsMEJBQTBCLG9CQUFvQixrQkFBa0IsRUFBRSxVQUFVLEVBQUUsMENBQTBDLE1BQU0sR0FBRyxVQUFVLGNBQWMsVUFBVSxLQUFLLE1BQU0sTUFBTSxVQUFVLDZCQUE2QixlQUFlLCtCQUErQiwrQ0FBK0MsY0FBYyxRQUFRLG9CQUFvQixFQUFFLCtDQUErQyxvQkFBb0IsOENBQThDLE9BQU8sU0FBUyxjQUFjLE1BQU0sR0FBRyxvQkFBb0IsOENBQThDLE1BQU0sNkNBQTZDLGVBQWUseUJBQXlCLGVBQWUsWUFBWSxrREFBa0QsZUFBZSw4SUFBOEkscUVBQXFFLHVLQUF1SyxFQUFFLFlBQVksY0FBYyxFQUFFLG9DQUFvQyxTQUFTLElBQUksaUJBQWlCLG9FQUFvRSxzSUFBc0ksTUFBTSxFQUFFLEdBQUcsK0JBQStCLEVBQUUsU0FBUywyQkFBMkIsWUFBWSxHQUFHLGlCQUFpQixhQUFhLGNBQWMsa0VBQWtFLHFCQUFxQixFQUFFLDRGQUE0RixnRkFBZ0YscUJBQXFCLHNCQUFzQixJQUFJLDRDQUE0QyxpQkFBaUIsU0FBUyxFQUFFLHFDQUFxQyxtQkFBbUIsb0JBQW9CLGVBQWUsRUFBRSxFQUFFLFNBQVMsMEJBQTBCLGNBQWMsSUFBSSw2QkFBNkIsbUdBQW1HLG9CQUFvQix3QkFBd0Isc0NBQXNDLG1CQUFtQiwyREFBMkQsUUFBUSxFQUFFLE9BQU8sbUJBQW1CLGlCQUFpQixlQUFlLDhDQUE4QyxnQ0FBZ0MsZUFBZSwyQ0FBMkMsNEZBQTRGLHFDQUFxQyxrQkFBa0Isb0hBQW9ILGlCQUFpQixpQkFBaUIsSUFBSSwwQkFBMEIsc0NBQXNDLG9CQUFvQixpQkFBaUIsY0FBYyw2QkFBNkIsOEJBQThCLGdDQUFnQywwQkFBMEIseUJBQXlCLGlCQUFpQixFQUFFLE1BQU0sYUFBYSxzQkFBc0IsbUVBQW1FLDZCQUE2QixpRUFBaUUsSUFBSSwyQkFBMkIsc0JBQXNCLFdBQVcsRUFBRSxTQUFTLDBCQUEwQixtQkFBbUIsYUFBYSx3QkFBd0IsY0FBYywyQ0FBMkMsY0FBYyw2QkFBNkIsa0JBQWtCLG1EQUFtRCxXQUFXLElBQUksU0FBUyxFQUFFLHVCQUF1Qix5QkFBeUIsUUFBUSxlQUFlLFFBQVEsZ0RBQWdELEVBQUUsU0FBUywwQkFBMEIsMkRBQTJELGFBQWEsT0FBTyxjQUFjLDRDQUE0Qyx1RkFBdUYsb0JBQW9CLGNBQWMsRUFBRSxPQUFPLGdDQUFnQyxJQUFJLDRDQUE0QyxpQkFBaUIsS0FBSyxFQUFFLEVBQUUsU0FBUywwQkFBMEIsMEJBQTBCLElBQUksNENBQTRDLHdCQUF3Qiw2QkFBNkIsY0FBYyxvQkFBb0IsRUFBRSxTQUFTLDBCQUEwQiwyQkFBMkIsZ0ZBQWdGLE9BQU8sNkJBQTZCLFVBQVUsU0FBUyxhQUFhLHVCQUF1Qiw4REFBOEQsa0JBQWtCLHdEQUF3RCxJQUFJLDhDQUE4QztBQUM1bFEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3Nhbml0eS1uZXh0bWVkaXVtL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2dyb3Etc3RvcmUvZGlzdC9icm93c2VyL2dyb3Etc3RvcmUuanM/NWI2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBlKGUpe3JldHVybiBlJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJkZWZhdWx0XCJpbiBlP2UuZGVmYXVsdDplfXZhciByPWUocmVxdWlyZShcImdyb3FcIikpLHQ9ZShyZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpKSxuPXJlcXVpcmUoXCJ0aHJvdHRsZS1kZWJvdW5jZVwiKSxvPXJlcXVpcmUoXCJncm9xLWpzXCIpLGk9cmVxdWlyZShcIm1lbmRvemFcIik7ZnVuY3Rpb24gdSgpe3JldHVybih1PU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3ZhciB0PWFyZ3VtZW50c1tyXTtmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSl9cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gcyhlLHIsdCl7dmFyIG4sbz1yLnRva2VuLGk9bmV3IGUoXCJodHRwczovL1wiK3IucHJvamVjdElkK1wiLmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9saXN0ZW4vXCIrci5kYXRhc2V0K1wiP3F1ZXJ5PSomZWZmZWN0Rm9ybWF0PW1lbmRvemFcIix7d2l0aENyZWRlbnRpYWxzOiEwLGhlYWRlcnM6bz97QXV0aG9yaXphdGlvbjpcIkJlYXJlciBcIitvfTp2b2lkIDB9KTtyZXR1cm4gaS5hZGRFdmVudExpc3RlbmVyKFwid2VsY29tZVwiLHQub3BlbiwhMSksaS5hZGRFdmVudExpc3RlbmVyKFwibXV0YXRpb25cIiwobj10Lm5leHQsZnVuY3Rpb24oZSl7dmFyIHI7dHJ5e3I9SlNPTi5wYXJzZShlLmRhdGEpfWNhdGNoKGUpe3JldHVybn1uKHIpfSksITEpLGkuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5uZWxFcnJvclwiLGZ1bmN0aW9uKGUpe3ZhciByO2kuY2xvc2UoKTt0cnl7cj1KU09OLnBhcnNlKGUuZGF0YSl9Y2F0Y2goZSl7cmV0dXJuIHZvaWQgdC5lcnJvcihuZXcgRXJyb3IoXCJVbmtub3duIGVycm9yIHBhcnNpbmcgbGlzdGVuZXIgbWVzc2FnZVwiKSl9dC5lcnJvcihuZXcgRXJyb3Ioci5tZXNzYWdlfHxyLmVycm9yfHxcIkxpc3RlbmVyIHJldHVybmVkIEhUVFAgXCIrci5zdGF0dXNDb2RlKSl9LCExKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGZ1bmN0aW9uKGUpe3ZhciByPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5sb2NhdGlvbi5vcmlnaW4sbj1yP1wiLCBhbmQgdGhhdCB0aGUgQ09SUy1vcmlnaW4gKFwiK3IrXCIpIGlzIGFsbG93ZWRcIjpcIlwiLG89ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZcIm1lc3NhZ2VcImluIGV9KGUpP1wiIChcIitlLm1lc3NhZ2UrXCIpXCI6XCJcIjt0LmVycm9yKG5ldyBFcnJvcihcIkVycm9yIGVzdGFibGlzaGluZyBsaXN0ZW5lciAtIGNoZWNrIHRoYXQgdGhlIHByb2plY3QgSUQgYW5kIGRhdGFzZXQgYXJlIGNvcnJlY3RcIituK28pKX0sITEpLHt1bnN1YnNjcmliZTpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoaS5jbG9zZSgpKX19fWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGUuX2lkLnN0YXJ0c1dpdGgoXCJkcmFmdHMuXCIpP2UuX2lkLnNsaWNlKDcpOmUuX2lkfWZ1bmN0aW9uIGEoZSxyKXt2YXIgdD11KHt9LGUpO3JldHVybiBkZWxldGUgdC5fcmV2LGkuYXBwbHlQYXRjaCh0LHIpfWZ1bmN0aW9uIGYoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9ZnVuY3Rpb24gZCgpe3ZhciBlLHIsdD0oZT1bXCIqW19pZCA9PSAkaWRdWzBdXCJdLHJ8fChyPWUuc2xpY2UoMCkpLGUucmF3PXIsZSk7cmV0dXJuIGQ9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiB2KGUscix0KXtpZighZS5zKXtpZih0IGluc3RhbmNlb2YgbCl7aWYoIXQucylyZXR1cm4gdm9pZCh0Lm89di5iaW5kKG51bGwsZSxyKSk7MSZyJiYocj10LnMpLHQ9dC52fWlmKHQmJnQudGhlbilyZXR1cm4gdm9pZCB0LnRoZW4odi5iaW5kKG51bGwsZSxyKSx2LmJpbmQobnVsbCxlLDIpKTtlLnM9cixlLnY9dDt2YXIgbj1lLm87biYmbihlKX19dmFyIGw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7fXJldHVybiBlLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKHIsdCl7dmFyIG49bmV3IGUsbz10aGlzLnM7aWYobyl7dmFyIGk9MSZvP3I6dDtpZihpKXt0cnl7dihuLDEsaSh0aGlzLnYpKX1jYXRjaChlKXt2KG4sMixlKX1yZXR1cm4gbn1yZXR1cm4gdGhpc31yZXR1cm4gdGhpcy5vPWZ1bmN0aW9uKGUpe3RyeXt2YXIgbz1lLnY7MSZlLnM/dihuLDEscj9yKG8pOm8pOnQ/dihuLDEsdChvKSk6dihuLDIsbyl9Y2F0Y2goZSl7dihuLDIsZSl9fSxufSxlfSgpO2Z1bmN0aW9uIGgoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBsJiYxJmUuc312YXIgbT1mdW5jdGlvbihlKXt2YXIgcj1lLnByb2plY3RJZCx0PWUuZGF0YXNldCxuPWUudG9rZW4sbz1lLmRvY3VtZW50TGltaXQ7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoZmV0Y2goXCJodHRwczovL1wiK3IrXCIuYXBpLnNhbml0eS5pby92MS9kYXRhL2V4cG9ydC9cIit0LHtjcmVkZW50aWFsczpcImluY2x1ZGVcIixoZWFkZXJzOm4/e0F1dGhvcml6YXRpb246XCJCZWFyZXIgXCIrbn06dm9pZCAwfSkpLnRoZW4oZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcihyKXt2YXIgdCxuLGk9ZnVuY3Rpb24oZSl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHJlYWQgYm9keSBmcm9tIHJlc3BvbnNlXCIpO3ZhciByLHQ9ITE7ZnVuY3Rpb24gbigpe3Q9ITAsciYmci5jYW5jZWwoKX1yZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydDpmdW5jdGlvbihvKXtyPWUuZ2V0UmVhZGVyKCk7dmFyIGk9bmV3IFRleHREZWNvZGVyLHU9XCJcIjtyLnJlYWQoKS50aGVuKGZ1bmN0aW9uIGUocyl7dHJ5e2lmKHMuZG9uZSlyZXR1cm4gdD9Qcm9taXNlLnJlc29sdmUoKTowPT09KHU9dS50cmltKCkpLmxlbmd0aD8oby5jbG9zZSgpLFByb21pc2UucmVzb2x2ZSgpKTooby5lbnF1ZXVlKEpTT04ucGFyc2UodSkpLG8uY2xvc2UoKSxQcm9taXNlLnJlc29sdmUoKSk7Zm9yKHZhciBjPSh1Kz1pLmRlY29kZShzLnZhbHVlLHtzdHJlYW06ITB9KSkuc3BsaXQoXCJcXG5cIiksYT0wO2E8Yy5sZW5ndGgtMTsrK2Epe3ZhciBmPWNbYV0udHJpbSgpO2lmKDA9PT1mLmxlbmd0aClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7dHJ5e28uZW5xdWV1ZShKU09OLnBhcnNlKGYpKX1jYXRjaChlKXtyZXR1cm4gby5lcnJvcihlKSxuKCksUHJvbWlzZS5yZXNvbHZlKCl9fWlmKHU9Y1tjLmxlbmd0aC0xXSwhcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7dmFyIGQ9ZnVuY3Rpb24odCxuKXt0cnl7dmFyIG89UHJvbWlzZS5yZXNvbHZlKHIucmVhZCgpKS50aGVuKGZ1bmN0aW9uKHIpe2Uocil9KX1jYXRjaChlKXtyZXR1cm4gbihlKX1yZXR1cm4gbyYmby50aGVuP28udGhlbih2b2lkIDAsbik6b30oMCxmdW5jdGlvbihlKXtvLmVycm9yKGUpfSk7cmV0dXJuIFByb21pc2UucmVzb2x2ZShkJiZkLnRoZW4/ZC50aGVuKGZ1bmN0aW9uKCl7fSk6dm9pZCAwKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSkuY2F0Y2goZnVuY3Rpb24oZSl7cmV0dXJuIG8uZXJyb3IoZSl9KX0sY2FuY2VsOm59KX0oZS5ib2R5KS5nZXRSZWFkZXIoKSx1PVtdLHM9ZnVuY3Rpb24oZSxyKXt2YXIgdDtkb3t2YXIgbj1lKCk7aWYobiYmbi50aGVuKXtpZighaChuKSl7dD0hMDticmVha31uPW4udn12YXIgbz1yKCk7aWYoaChvKSYmKG89by52KSwhbylyZXR1cm4gbn13aGlsZSghby50aGVuKTt2YXIgaT1uZXcgbCx1PXYuYmluZChudWxsLGksMik7cmV0dXJuKHQ/bi50aGVuKHMpOm8udGhlbihjKSkudGhlbih2b2lkIDAsdSksaTtmdW5jdGlvbiBzKHQpe2ZvcihuPXQ7aChvPXIoKSkmJihvPW8udiksbzspe2lmKG8udGhlbilyZXR1cm4gdm9pZCBvLnRoZW4oYykudGhlbih2b2lkIDAsdSk7aWYoKG49ZSgpKSYmbi50aGVuKXtpZighaChuKSlyZXR1cm4gdm9pZCBuLnRoZW4ocykudGhlbih2b2lkIDAsdSk7bj1uLnZ9fXYoaSwxLG4pfWZ1bmN0aW9uIGModCl7aWYodCl7ZG97aWYoKG49ZSgpKSYmbi50aGVuKXtpZighaChuKSlyZXR1cm4gdm9pZCBuLnRoZW4ocykudGhlbih2b2lkIDAsdSk7bj1uLnZ9aWYoaCh0PXIoKSkmJih0PXQudiksIXQpcmV0dXJuIHZvaWQgdihpLDEsbil9d2hpbGUoIXQudGhlbik7dC50aGVuKGMpLnRoZW4odm9pZCAwLHUpfWVsc2UgdihpLDEsbil9fShmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoaS5yZWFkKCkpLnRoZW4oZnVuY3Rpb24oZSl7aWYoZnVuY3Rpb24oZSl7cmV0dXJuISFlJiZcImVycm9yXCJpbiBlJiZcIm9iamVjdFwiPT10eXBlb2YgZS5lcnJvciYmbnVsbCE9PWUuZXJyb3ImJlwiZGVzY3JpcHRpb25cImluIGUuZXJyb3ImJlwic3RyaW5nXCI9PXR5cGVvZiBlLmVycm9yLmRlc2NyaXB0aW9uJiYhKFwiX2lkXCJpbiBlKX0obj0odD1lKS52YWx1ZSkpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3Igc3RyZWFtaW5nIGRhdGFzZXQ6IFwiK24uZXJyb3IpO2lmKG4mJiFuLl9pZC5zdGFydHNXaXRoKFwiXy5cIikmJnUucHVzaChuKSxvJiZ1Lmxlbmd0aD5vKXRocm93IGkuY2FuY2VsKFwiUmVhY2hlZCBkb2N1bWVudCBsaW1pdFwiKSxuZXcgRXJyb3IoXCJFcnJvciBzdHJlYW1pbmcgZGF0YXNldDogUmVhY2hlZCBsaW1pdCBvZiBcIitvK1wiIGRvY3VtZW50c1wiKX0pfSxmdW5jdGlvbigpe3JldHVybiF0LmRvbmV9KTtyZXR1cm4gcyYmcy50aGVuP3MudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gdX0pOnV9dmFyIHQ9ZnVuY3Rpb24oKXtpZigyMDAhPT1lLnN0YXR1cylyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUuanNvbigpKS50aGVuKGZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIkVycm9yIHN0cmVhbWluZyBkYXRhc2V0OiBcIisoXCJvYmplY3RcIj09dHlwZW9mKHI9ZSkmJlwiZXJyb3JcImluIHImJlwibWVzc2FnZVwiaW4gcj9yLm1lc3NhZ2V8fHIuZXJyb3I6XCI8dW5rbm93biBlcnJvcj5cIikpO3ZhciByfSl9KCk7cmV0dXJuIHQmJnQudGhlbj90LnRoZW4ocik6cigpfSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX07ZXhwb3J0cy5ncm9xPXIsZXhwb3J0cy5ncm9xU3RvcmU9ZnVuY3Rpb24oZSl7aWYoZnVuY3Rpb24oKXt2YXIgZT1bXCJFdmVudFNvdXJjZVwiLFwiUmVhZGFibGVTdHJlYW1cIixcImZldGNoXCJdLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4hKGUgaW4gd2luZG93KX0pO2lmKGUubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlciBub3Qgc3VwcG9ydGVkLiBNaXNzaW5nIGJyb3dzZXIgQVBJczogXCIrZS5qb2luKFwiLCBcIikpfSgpLGUudG9rZW4pdGhyb3cgbmV3IEVycm9yKFwiYHRva2VuYCBvcHRpb24gbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgaW4gYnJvd3NlclwiKTtyZXR1cm4gZnVuY3Rpb24oZSxpKXt2YXIgdixsPWZ1bmN0aW9uKGUscil7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoaCgpKS50aGVuKGZ1bmN0aW9uKCl7dmFyIHQ9by5wYXJzZShlLHtwYXJhbXM6cn0pO3JldHVybiBQcm9taXNlLnJlc29sdmUoby5ldmFsdWF0ZSh0LHtkYXRhc2V0Om0scGFyYW1zOnJ9KSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXQoKX0pfSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0saD1mdW5jdGlvbigpe3RyeXtyZXR1cm4gdnx8KHY9ZnVuY3Rpb24oZSxyLHQpe3ZhciBuPXQuZ2V0RG9jdW1lbnRzLG89dC5FdmVudFNvdXJjZSxpPWUucHJvamVjdElkLGQ9ZS5kYXRhc2V0LHY9ZS5vdmVybGF5RHJhZnRzLGw9ZS5kb2N1bWVudExpbWl0O2lmKCFlLmxpc3RlbilyZXR1cm57dW5zdWJzY3JpYmU6Zixsb2FkZWQ6bih7cHJvamVjdElkOmksZGF0YXNldDpkLGRvY3VtZW50TGltaXQ6bH0pLnRoZW4oaikudGhlbihmKX07dmFyIGgsbSxwLHcsYixnLHk9bmV3IE1hcCxQPVtdLEU9bmV3IFByb21pc2UoZnVuY3Rpb24oZSxyKXttPWUscD1yfSk7cmV0dXJue3Vuc3Vic2NyaWJlOnMobyxlLHtuZXh0OmZ1bmN0aW9uKGUpe2g/KGZ1bmN0aW9uKGUpe2lmKGUuZWZmZWN0cyYmIWUuZG9jdW1lbnRJZC5zdGFydHNXaXRoKFwiXy5cIikpe3ZhciByPXkuZ2V0KGUuZG9jdW1lbnRJZCl8fG51bGw7IWZ1bmN0aW9uKGUscil7dmFyIHQ9eS5nZXQoZSksbj1ofHxbXSxvPXQ/bi5pbmRleE9mKHQpOi0xOy0xPT09byYmcj8obi5wdXNoKHIpLHkuc2V0KGUscikpOnI/KG4uc3BsaWNlKG8sMSxyKSx5LnNldChlLHIpKToobi5zcGxpY2UobywxKSx5LmRlbGV0ZShlKSl9KGUuZG9jdW1lbnRJZCxhKHIsZS5lZmZlY3RzLmFwcGx5KSl9fShlKSxmdW5jdGlvbihlLHIpe2NsZWFyVGltZW91dChnKSxiIT09ci50cmFuc2FjdGlvbklkJiZ3PyhqKHcpLGI9dm9pZCAwKTooYj1yLnRyYW5zYWN0aW9uSWQsdz1lLnNsaWNlKCkpLGc9c2V0VGltZW91dChqLDI1LGUuc2xpY2UoKSl9KGgsZSkpOlAucHVzaChlKX0sb3BlbjpmdW5jdGlvbigpe3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG4oe3Byb2plY3RJZDppLGRhdGFzZXQ6ZCxkb2N1bWVudExpbWl0Omx9KSkudGhlbihmdW5jdGlvbihlKXsoaD1mdW5jdGlvbihlLHIpe3ZhciB0PW5ldyBNYXA7cmV0dXJuIHIuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgcj10LmdldChlLmRvY3VtZW50SWQpfHxbXTtyLnB1c2goZSksdC5zZXQoZS5kb2N1bWVudElkLHIpfSksdC5mb3JFYWNoKGZ1bmN0aW9uKHIsdCl7dmFyIG49ZS5maW5kKGZ1bmN0aW9uKGUpe3JldHVybiBlLl9pZD09PXR9KTtpZihuKXt2YXIgbz0hMSxpPW47ci5mb3JFYWNoKGZ1bmN0aW9uKGUpeyhvPW98fGUucHJldmlvdXNSZXY9PT1uLl9yZXYpJiZlLmVmZmVjdHMmJihpPWEoaSxlLmVmZmVjdHMuYXBwbHkpKX0pLGUuc3BsaWNlKGUuaW5kZXhPZihuKSwxLGkpfWVsc2UgY29uc29sZS53YXJuKFwiUmVjZWl2ZWQgbXV0YXRpb24gZm9yIG1pc3NpbmcgZG9jdW1lbnQgJXNcIix0KX0pLGV9KGUsUCkpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHkuc2V0KGUuX2lkLGUpfSksaihoKSxtKCl9KX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSxlcnJvcjpmdW5jdGlvbihlKXtyZXR1cm4gcChlKX19KS51bnN1YnNjcmliZSxsb2FkZWQ6RX07ZnVuY3Rpb24gaihlKXt3PXZvaWQgMCxnPXZvaWQgMCxiPXZvaWQgMCxyKHY/ZnVuY3Rpb24oZSl7dmFyIHI9bmV3IE1hcDtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXIuZ2V0KGMoZSkpO2UuX2lkLnN0YXJ0c1dpdGgoXCJkcmFmdHMuXCIpP3Iuc2V0KGMoZSksZnVuY3Rpb24oZSl7cmV0dXJuIHUoe30sZSx7X2lkOmMoZSl9KX0oZSkpOnR8fHIuc2V0KGUuX2lkLGUpfSksQXJyYXkuZnJvbShyLnZhbHVlcygpKX0oZSk6ZSl9fShlLGZ1bmN0aW9uKGUpe209ZSxwKCl9LGkpKSxQcm9taXNlLnJlc29sdmUodi5sb2FkZWQpLnRoZW4oZnVuY3Rpb24oKXt9KX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSxtPVtdLHA9bi50aHJvdHRsZShlLnN1YnNjcmlwdGlvblRocm90dGxlTXN8fDUwLGZ1bmN0aW9uKCl7dy5mb3JFYWNoKGIpfSksdz1bXTtmdW5jdGlvbiBiKGUpe3JldHVybiBsKGUucXVlcnksZS5wYXJhbXMpLnRoZW4oZnVuY3Rpb24ocil7XCJwcmV2aW91c1Jlc3VsdFwiaW4gZSYmdChlLnByZXZpb3VzUmVzdWx0LHIpfHwoZS5wcmV2aW91c1Jlc3VsdD1yLGUuY2FsbGJhY2sodm9pZCAwLHIpKX0pLmNhdGNoKGZ1bmN0aW9uKHIpe2UuY2FsbGJhY2socil9KX1yZXR1cm57cXVlcnk6bCxnZXREb2N1bWVudDpmdW5jdGlvbihlKXt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShoKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gbChyKGQoKSkse2lkOmV9KX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19LGdldERvY3VtZW50czpmdW5jdGlvbihlKXt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShoKCkpLnRoZW4oZnVuY3Rpb24oKXt2YXIgcj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4nKltfaWQgPT0gXCInK2UrJ1wiXVswXSd9KS5qb2luKFwiLFxcblwiKTtyZXR1cm4gbChcIltcIityK1wiXVwiKX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19LHN1YnNjcmliZTpmdW5jdGlvbihyLHQsbil7aWYoIWUubGlzdGVuKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgYHN1YnNjcmliZSgpYCB3aXRob3V0IGBsaXN0ZW46IHRydWVgXCIpO3ZhciBvPXtxdWVyeTpyLHBhcmFtczp0LGNhbGxiYWNrOm59O3cucHVzaChvKTt2YXIgaT0hMTtyZXR1cm4gYihvKSx7dW5zdWJzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm4gaXx8KGk9ITAsdy5zcGxpY2Uody5pbmRleE9mKG8pLDEpKSxQcm9taXNlLnJlc29sdmUoKX19fSxjbG9zZTpmdW5jdGlvbigpe3JldHVybiBwLmNhbmNlbCgpLHY/di51bnN1YnNjcmliZSgpOlByb21pc2UucmVzb2x2ZSgpfX19KGUse0V2ZW50U291cmNlOndpbmRvdy5FdmVudFNvdXJjZSxnZXREb2N1bWVudHM6bX0pfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3Etc3RvcmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../sanity-nextmedium/node_modules/@sanity/groq-store/dist/browser/groq-store.js\n");

/***/ }),

/***/ "../sanity-nextmedium/node_modules/@sanity/groq-store/node_modules/groq-js/dist/groq-js.esm.js":
/*!*****************************************************************************************************!*\
  !*** ../sanity-nextmedium/node_modules/@sanity/groq-store/node_modules/groq-js/dist/groq-js.esm.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"evaluate\": function() { return /* binding */ evaluateQuery; },\n/* harmony export */   \"parse\": function() { return /* binding */ parse; }\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nclass MarkProcessor {\n  constructor(string3, marks, parseOptions) {\n    this.allowBoost = false;\n    this.string = string3;\n    this.marks = marks;\n    this.index = 0;\n    this.parseOptions = parseOptions;\n  }\n  hasMark(pos = 0) {\n    return this.index + pos < this.marks.length;\n  }\n  getMark(pos = 0) {\n    return this.marks[this.index + pos];\n  }\n  shift() {\n    this.index += 1;\n  }\n  process(visitor) {\n    const mark = this.marks[this.index];\n    this.shift();\n    const func = visitor[mark.name];\n    if (!func) {\n      throw new Error(`Unknown handler: ${mark.name}`);\n    }\n    return func.call(visitor, this, mark);\n  }\n  processString() {\n    this.shift();\n    return this.processStringEnd();\n  }\n  processStringEnd() {\n    const prev = this.marks[this.index - 1];\n    const curr = this.marks[this.index];\n    this.shift();\n    return this.string.slice(prev.position, curr.position);\n  }\n  slice(len) {\n    const pos = this.marks[this.index].position;\n    return this.string.slice(pos, pos + len);\n  }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str);\n  }\n  return null;\n}\nfunction formatRFC3339(d) {\n  const year = addLeadingZero(d.getUTCFullYear(), 4);\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2);\n  const day = addLeadingZero(d.getUTCDate(), 2);\n  const hour = addLeadingZero(d.getUTCHours(), 2);\n  const minute = addLeadingZero(d.getUTCMinutes(), 2);\n  const second = addLeadingZero(d.getUTCSeconds(), 2);\n  let fractionalSecond = \"\";\n  const millis = d.getMilliseconds();\n  if (millis != 0) {\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`;\n  }\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;\n}\nfunction addLeadingZero(num, targetLength) {\n  let str = num.toString();\n  while (str.length < targetLength) {\n    str = `0${str}`;\n  }\n  return str;\n}\nfunction escapeRegExp(string3) {\n  return string3.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n  const re = [];\n  for (const part of pattern.split(\".\")) {\n    if (part === \"*\") {\n      re.push(\"[^.]+\");\n    } else if (part === \"**\") {\n      re.push(\".*\");\n    } else {\n      re.push(escapeRegExp(part));\n    }\n  }\n  return new RegExp(`^${re.join(\".\")}$`);\n}\nclass Path {\n  constructor(pattern) {\n    this.pattern = pattern;\n    this.patternRe = pathRegExp(pattern);\n  }\n  matches(str) {\n    return this.patternRe.test(str);\n  }\n  toJSON() {\n    return this.pattern;\n  }\n}\nclass StreamValue {\n  constructor(generator) {\n    this.type = \"stream\";\n    this.generator = generator;\n    this.ticker = null;\n    this.isDone = false;\n    this.data = [];\n  }\n  isArray() {\n    return true;\n  }\n  async get() {\n    const result = [];\n    for await (const value of this) {\n      result.push(await value.get());\n    }\n    return result;\n  }\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i];\n      }\n      if (this.isDone) {\n        return;\n      }\n      await this._nextTick();\n    }\n  }\n  _nextTick() {\n    if (this.ticker) {\n      return this.ticker;\n    }\n    let currentResolver;\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve;\n      });\n    };\n    const tick = () => {\n      currentResolver();\n      setupTicker();\n    };\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value);\n        tick();\n      }\n      this.isDone = true;\n      tick();\n    };\n    setupTicker();\n    fetch();\n    return this.ticker;\n  }\n}\nclass StaticValue {\n  constructor(data, type) {\n    this.data = data;\n    this.type = type;\n  }\n  isArray() {\n    return this.type === \"array\";\n  }\n  async get() {\n    return this.data;\n  }\n  [Symbol.asyncIterator]() {\n    if (Array.isArray(this.data)) {\n      return function* (data) {\n        for (const element of data) {\n          yield fromJS(element);\n        }\n      }(this.data);\n    }\n    throw new Error(`Cannot iterate over: ${this.type}`);\n  }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\");\nconst TRUE_VALUE = new StaticValue(true, \"boolean\");\nconst FALSE_VALUE = new StaticValue(false, \"boolean\");\nclass DateTime {\n  constructor(date) {\n    this.date = date;\n  }\n  static parseToValue(str) {\n    const date = parseRFC3339(str);\n    if (date) {\n      return new StaticValue(new DateTime(date), \"datetime\");\n    }\n    return NULL_VALUE;\n  }\n  equals(other) {\n    return this.date.getTime() == other.date.getTime();\n  }\n  add(secs) {\n    const copy = new Date(this.date.getTime());\n    copy.setTime(copy.getTime() + secs * 1e3);\n    return new DateTime(copy);\n  }\n  difference(other) {\n    return (this.date.getTime() - other.date.getTime()) / 1e3;\n  }\n  compareTo(other) {\n    return this.date.getTime() - other.date.getTime();\n  }\n  toString() {\n    return formatRFC3339(this.date);\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction fromNumber(num) {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, \"number\");\n  }\n  return NULL_VALUE;\n}\nfunction fromString(str) {\n  return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n  return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path2) {\n  return new StaticValue(path2, \"path\");\n}\nfunction isIterator(obj) {\n  return obj && typeof obj.next === \"function\";\n}\nfunction fromJS(val) {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value);\n      }\n    });\n  } else if (val === null || val === void 0) {\n    return NULL_VALUE;\n  }\n  return new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n  if (data === null || typeof data === \"undefined\") {\n    return \"null\";\n  }\n  if (Array.isArray(data)) {\n    return \"array\";\n  }\n  if (data instanceof Path) {\n    return \"path\";\n  }\n  if (data instanceof DateTime) {\n    return \"datetime\";\n  }\n  return typeof data;\n}\nconst TYPE_ORDER = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4\n};\nfunction partialCompare(a, b) {\n  const aType = getType(a);\n  const bType = getType(b);\n  if (aType !== bType) {\n    return null;\n  }\n  switch (aType) {\n    case \"number\":\n    case \"boolean\":\n      return a - b;\n    case \"string\":\n      if (a < b)\n        return -1;\n      if (a > b)\n        return 1;\n      return 0;\n    case \"datetime\":\n      return a.compareTo(b);\n    default:\n      return null;\n  }\n}\nfunction totalCompare(a, b) {\n  const aType = getType(a);\n  const bType = getType(b);\n  const aTypeOrder = TYPE_ORDER[aType] || 100;\n  const bTypeOrder = TYPE_ORDER[bType] || 100;\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder;\n  }\n  let result = partialCompare(a, b);\n  if (result === null) {\n    result = 0;\n  }\n  return result;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nconst MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false;\n  }\n  return patterns.every((pattern) => pattern(tokens));\n}\nfunction matchTokenize(text) {\n  return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n  const termsRe = matchPatternRegex(text);\n  return termsRe.map((re) => (tokens) => tokens.some((token) => re.test(token)));\n}\nfunction matchPatternRegex(text) {\n  const terms = text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || [];\n  return terms.map((term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, \".*\")}$`, \"i\"));\n}\nasync function gatherText(value, cb) {\n  if (value.type === \"string\") {\n    cb(value.data);\n    return true;\n  }\n  if (value.isArray()) {\n    let success = true;\n    for await (const part of value) {\n      if (part.type === \"string\") {\n        cb(part.data);\n      } else {\n        success = false;\n      }\n    }\n    return success;\n  }\n  return false;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n  if (node.type === \"OpCall\" && node.op === \"match\") {\n    return evaluateMatchScore(node.left, node.right, scope, execute);\n  }\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = await evaluateScore(node.args[0], scope, execute);\n    const boost2 = await execute(node.args[1], scope);\n    if (boost2.type === \"number\" && innerScore > 0) {\n      return innerScore + boost2.data;\n    }\n    return 0;\n  }\n  switch (node.type) {\n    case \"Or\": {\n      const leftScore = await evaluateScore(node.left, scope, execute);\n      const rightScore = await evaluateScore(node.right, scope, execute);\n      return leftScore + rightScore;\n    }\n    case \"And\": {\n      const leftScore = await evaluateScore(node.left, scope, execute);\n      const rightScore = await evaluateScore(node.right, scope, execute);\n      if (leftScore === 0 || rightScore === 0)\n        return 0;\n      return leftScore + rightScore;\n    }\n    default: {\n      const res = await execute(node, scope);\n      return res.type === \"boolean\" && res.data === true ? 1 : 0;\n    }\n  }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n  const text = await execute(left, scope);\n  const pattern = await execute(right, scope);\n  let tokens = [];\n  let terms = [];\n  await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part));\n  });\n  const didSucceed = await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part));\n  });\n  if (!didSucceed) {\n    return 0;\n  }\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0;\n  }\n  let score2 = 0;\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);\n    score2 += freq * (BM25k + 1) / (freq + BM25k);\n  }\n  return score2;\n}\nasync function portableTextContent(value) {\n  if (value.type === \"object\") {\n    return blockText(value.data);\n  } else if (value.isArray()) {\n    const texts = await arrayText(value);\n    if (texts.length > 0) {\n      return texts.join(\"\\n\\n\");\n    }\n  }\n  return null;\n}\nasync function arrayText(value, result = []) {\n  for await (const block of value) {\n    if (block.type === \"object\") {\n      const text = blockText(block.data);\n      if (text !== null)\n        result.push(text);\n    } else if (block.isArray()) {\n      await arrayText(block, result);\n    }\n  }\n  return result;\n}\nfunction blockText(obj) {\n  if (typeof obj._type !== \"string\")\n    return null;\n  const children = obj.children;\n  if (!Array.isArray(children))\n    return null;\n  let result = \"\";\n  for (const child of children) {\n    if (child && typeof child === \"object\" && typeof child._type === \"string\" && child._type === \"span\" && typeof child.text === \"string\") {\n      result += child.text;\n    }\n  }\n  return result;\n}\nfunction hasReference(value, pathSet) {\n  switch (getType(value)) {\n    case \"array\":\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true;\n        }\n      }\n      break;\n    case \"object\":\n      if (value._ref) {\n        return pathSet.has(value._ref);\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true;\n        }\n      }\n      break;\n  }\n  return false;\n}\nfunction countUTF8(str) {\n  let count2 = 0;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    if (code >= 55296 && code <= 56319) {\n      continue;\n    }\n    count2++;\n  }\n  return count2;\n}\nconst global = {};\nglobal.coalesce = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope);\n    if (value.type !== \"null\") {\n      return value;\n    }\n  }\n  return NULL_VALUE;\n};\nglobal.count = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (!inner.isArray()) {\n    return NULL_VALUE;\n  }\n  let num = 0;\n  for await (const _ of inner) {\n    num++;\n  }\n  return fromNumber(num);\n};\nglobal.count.arity = 1;\nglobal.dateTime = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope);\n  if (val.type === \"datetime\") {\n    return val;\n  }\n  if (val.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return DateTime.parseToValue(val.data);\n};\nglobal.dateTime.arity = 1;\nglobal.defined = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  return inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\nglobal.defined.arity = 1;\nglobal.identity = async function identity(args, scope) {\n  return fromString(scope.context.identity);\n};\nglobal.identity.arity = 0;\nglobal.length = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type === \"string\") {\n    return fromNumber(countUTF8(inner.data));\n  }\n  if (inner.isArray()) {\n    let num = 0;\n    for await (const _ of inner) {\n      num++;\n    }\n    return fromNumber(num);\n  }\n  return NULL_VALUE;\n};\nglobal.length.arity = 1;\nglobal.path = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromPath(new Path(inner.data));\n};\nglobal.path.arity = 1;\nglobal.string = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  switch (value.type) {\n    case \"number\":\n    case \"string\":\n    case \"boolean\":\n    case \"datetime\":\n      return fromString(`${value.data}`);\n    default:\n      return NULL_VALUE;\n  }\n};\nglobal.string.arity = 1;\nglobal.references = async function references(args, scope, execute) {\n  const pathSet = new Set();\n  for (const arg of args) {\n    const path2 = await execute(arg, scope);\n    if (path2.type === \"string\") {\n      pathSet.add(path2.data);\n    } else if (path2.isArray()) {\n      for await (const elem of path2) {\n        if (elem.type === \"string\") {\n          pathSet.add(elem.data);\n        }\n      }\n    }\n  }\n  if (pathSet.size === 0) {\n    return FALSE_VALUE;\n  }\n  const scopeValue = await scope.value.get();\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\nglobal.references.arity = (c) => c >= 1;\nglobal.round = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"number\") {\n    return NULL_VALUE;\n  }\n  const num = value.data;\n  let prec = 0;\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope);\n    if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE;\n    }\n    prec = precValue.data;\n  }\n  if (prec === 0) {\n    if (num < 0) {\n      return fromNumber(-Math.round(-num));\n    }\n    return fromNumber(Math.round(num));\n  }\n  return fromNumber(Number(num.toFixed(prec)));\n};\nglobal.round.arity = (count2) => count2 >= 1 && count2 <= 2;\nglobal.now = async function now(args, scope) {\n  return fromString(scope.context.timestamp.toISOString());\n};\nglobal.now.arity = 0;\nglobal.boost = async function boost() {\n  throw new Error(\"unexpected boost call\");\n};\nglobal.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nglobal.lower = string2.lower;\nglobal.upper = string2.upper;\nconst pt = {};\npt.text = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  const text = await portableTextContent(value);\n  if (text === null) {\n    return NULL_VALUE;\n  }\n  return fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function(args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId);\n  }\n  return NULL_VALUE;\n};\nsanity.dataset = async function(args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset);\n  }\n  return NULL_VALUE;\n};\nconst pipeFunctions = {};\npipeFunctions.order = async function order(base, args, scope, execute) {\n  await true;\n  if (!base.isArray()) {\n    return NULL_VALUE;\n  }\n  const mappers = [];\n  const directions = [];\n  let n = 0;\n  for (let mapper of args) {\n    let direction = \"asc\";\n    if (mapper.type === \"Desc\") {\n      direction = \"desc\";\n      mapper = mapper.base;\n    } else if (mapper.type === \"Asc\") {\n      mapper = mapper.base;\n    }\n    mappers.push(mapper);\n    directions.push(direction);\n    n++;\n  }\n  const aux = [];\n  let idx = 0;\n  for await (const value of base) {\n    const newScope = scope.createNested(value);\n    const tuple = [await value.get(), idx];\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope);\n      tuple.push(await result.get());\n    }\n    aux.push(tuple);\n    idx++;\n  }\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n      if (directions[i] === \"desc\") {\n        c = -c;\n      }\n      if (c !== 0) {\n        return c;\n      }\n    }\n    return aTuple[1] - bTuple[1];\n  });\n  return fromJS(aux.map((v) => v[0]));\n};\npipeFunctions.order.arity = (count2) => count2 >= 1;\npipeFunctions.score = async function score(base, args, scope, execute) {\n  if (!base.isArray())\n    return NULL_VALUE;\n  const unknown = [];\n  const scored = [];\n  for await (const value of base) {\n    if (value.type !== \"object\") {\n      unknown.push(await value.get());\n      continue;\n    }\n    const newScope = scope.createNested(value);\n    let valueScore = typeof value.data._score === \"number\" ? value.data._score : 0;\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute);\n    }\n    const newObject = Object.assign({}, value.data, { _score: valueScore });\n    scored.push(newObject);\n  }\n  scored.sort((a, b) => b._score - a._score);\n  return fromJS(scored);\n};\npipeFunctions.score.arity = (count2) => count2 >= 1;\nconst delta = {};\ndelta.operation = async function(args, scope) {\n  const hasBefore = scope.context.before !== null;\n  const hasAfter = scope.context.after !== null;\n  if (hasBefore && hasAfter) {\n    return fromString(\"update\");\n  }\n  if (hasAfter) {\n    return fromString(\"create\");\n  }\n  if (hasBefore) {\n    return fromString(\"delete\");\n  }\n  return NULL_VALUE;\n};\ndelta.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst namespaces = {\n  global,\n  string: string2,\n  pt,\n  delta,\n  diff,\n  sanity\n};\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]+\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  if (result.type === \"error\")\n    return result;\n  pos = skipWS(str, result.position);\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1;\n    }\n    return { type: \"error\", position: pos };\n  }\n  delete result.position;\n  delete result.failPosition;\n  return result;\n}\nfunction parseExpr(str, pos, level) {\n  let startPos = pos;\n  let token = str[pos];\n  let marks;\n  switch (token) {\n    case \"+\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"pos\", position: startPos }].concat(rhs.marks);\n      pos = rhs.position;\n      break;\n    }\n    case \"-\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"neg\", position: startPos }].concat(rhs.marks);\n      pos = rhs.position;\n      break;\n    }\n    case \"(\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n      if (rhs.type === \"error\")\n        return rhs;\n      pos = skipWS(str, rhs.position);\n      switch (str[pos]) {\n        case \",\": {\n          marks = [{ name: \"tuple\", position: startPos }].concat(rhs.marks);\n          pos = skipWS(str, pos + 1);\n          while (true) {\n            rhs = parseExpr(str, pos, 0);\n            if (rhs.type === \"error\")\n              return rhs;\n            pos = skipWS(str, rhs.position);\n            if (str[pos] !== \",\")\n              break;\n            pos = skipWS(str, pos + 1);\n          }\n          if (str[pos] !== \")\")\n            return { type: \"error\", position: pos };\n          pos++;\n          marks.push({ name: \"tuple_end\", position: pos });\n          break;\n        }\n        case \")\": {\n          pos++;\n          marks = [{ name: \"group\", position: startPos }].concat(rhs.marks);\n          break;\n        }\n        default:\n          return { type: \"error\", position: pos };\n      }\n      break;\n    }\n    case \"!\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"not\", position: startPos }].concat(rhs.marks);\n      pos = rhs.position;\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      if (result.type === \"error\")\n        return result;\n      marks = result.marks;\n      pos = result.position;\n      break;\n    }\n    case \"[\":\n      marks = [{ name: \"array\", position: pos }];\n      pos = skipWS(str, pos + 1);\n      if (str[pos] !== \"]\") {\n        while (true) {\n          if (str.slice(pos, pos + 3) === \"...\") {\n            marks.push({ name: \"array_splat\", position: pos });\n            pos = skipWS(str, pos + 3);\n          }\n          let res = parseExpr(str, pos, 0);\n          if (res.type === \"error\")\n            return res;\n          marks = marks.concat(res.marks);\n          pos = res.position;\n          pos = skipWS(str, pos);\n          if (str[pos] !== \",\")\n            break;\n          pos = skipWS(str, pos + 1);\n          if (str[pos] === \"]\")\n            break;\n        }\n      }\n      if (str[pos] === \"]\") {\n        pos++;\n        marks.push({ name: \"array_end\", position: pos });\n      } else {\n        return { type: \"error\", position: pos };\n      }\n      break;\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === \"error\")\n        return result;\n      marks = result.marks;\n      pos = result.position;\n      break;\n    }\n    case \"^\": {\n      pos++;\n      marks = [];\n      while (str[pos] === \".\" && str[pos + 1] === \"^\") {\n        marks.push({ name: \"dblparent\", position: startPos });\n        pos += 2;\n      }\n      marks.push({ name: \"parent\", position: startPos });\n      break;\n    }\n    case \"@\":\n      marks = [{ name: \"this\", position: startPos }];\n      pos++;\n      break;\n    case \"*\":\n      marks = [{ name: \"everything\", position: startPos }];\n      pos++;\n      break;\n    case \"$\": {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      if (identLen) {\n        pos += 1 + identLen;\n        marks = [\n          { name: \"param\", position: startPos },\n          { name: \"ident\", position: startPos + 1 },\n          { name: \"ident_end\", position: pos }\n        ];\n      }\n      break;\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = \"integer\";\n        if (str[pos] === \".\") {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          if (fracLen) {\n            name = \"float\";\n            pos += 1 + fracLen;\n          }\n        }\n        if (str[pos] === \"e\" || str[pos] === \"E\") {\n          name = \"sci\";\n          pos++;\n          if (str[pos] === \"+\" || str[pos] === \"-\") {\n            pos++;\n          }\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen)\n            return { type: \"error\", position: pos };\n          pos += expLen;\n        }\n        marks = [\n          { name, position: startPos },\n          { name: name + \"_end\", position: pos }\n        ];\n        break;\n      }\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        pos += identLen;\n        switch (str[pos]) {\n          case \":\":\n          case \"(\": {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === \"error\")\n              return result;\n            marks = result.marks;\n            pos = result.position;\n            break;\n          }\n          default: {\n            marks = [\n              { name: \"this_attr\", position: startPos },\n              { name: \"ident\", position: startPos },\n              { name: \"ident_end\", position: pos }\n            ];\n          }\n        }\n        break;\n      }\n    }\n  }\n  if (!marks) {\n    return { type: \"error\", position: pos };\n  }\n  let lhsLevel = 12;\n  let trav;\n  loop:\n    while (true) {\n      let innerPos = skipWS(str, pos);\n      if (innerPos === str.length) {\n        pos = innerPos;\n        break;\n      }\n      trav = parseTraversal(str, innerPos);\n      if (trav.type === \"success\") {\n        marks.unshift({ name: \"traverse\", position: startPos });\n        while (trav.type === \"success\") {\n          marks = marks.concat(trav.marks);\n          pos = trav.position;\n          trav = parseTraversal(str, skipWS(str, pos));\n        }\n        marks.push({ name: \"traversal_end\", position: pos });\n        continue;\n      }\n      let token2 = str[innerPos];\n      switch (token2) {\n        case \"=\": {\n          let nextToken = str[innerPos + 1];\n          switch (nextToken) {\n            case \">\": {\n              if (level > PREC_PAIR || lhsLevel <= PREC_PAIR)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks = marks.concat(rhs.marks);\n              marks.unshift({ name: \"pair\", position: startPos });\n              pos = rhs.position;\n              lhsLevel = PREC_PAIR;\n              break;\n            }\n            case \"=\": {\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks.unshift({ name: \"comp\", position: startPos });\n              marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\n              marks = marks.concat(rhs.marks);\n              pos = rhs.position;\n              lhsLevel = PREC_COMP;\n              break;\n            }\n            default:\n              break loop;\n          }\n          break;\n        }\n        case \"+\": {\n          if (level > PREC_ADD || lhsLevel < PREC_ADD)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"add\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_ADD;\n          break;\n        }\n        case \"-\": {\n          if (level > PREC_SUB || lhsLevel < PREC_SUB)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"sub\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_SUB;\n          break;\n        }\n        case \"*\": {\n          if (str[innerPos + 1] === \"*\") {\n            if (level > PREC_POW || lhsLevel <= PREC_POW)\n              break loop;\n            let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n            if (rhs2.type === \"error\")\n              return rhs2;\n            marks = marks.concat(rhs2.marks);\n            marks.unshift({ name: \"pow\", position: startPos });\n            pos = rhs2.position;\n            lhsLevel = PREC_POW;\n            break;\n          }\n          if (level > PREC_MUL || lhsLevel < PREC_MUL)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"mul\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_MUL;\n          break;\n        }\n        case \"/\": {\n          if (level > PREC_DIV || lhsLevel < PREC_DIV)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"div\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_DIV;\n          break;\n        }\n        case \"%\": {\n          if (level > PREC_MOD || lhsLevel < PREC_MOD)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"mod\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_MOD;\n          break;\n        }\n        case \"<\":\n        case \">\": {\n          if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n            break loop;\n          let nextPos = innerPos + 1;\n          if (str[nextPos] === \"=\") {\n            nextPos++;\n          }\n          let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks.unshift({ name: \"comp\", position: startPos });\n          marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: nextPos });\n          marks = marks.concat(rhs.marks);\n          pos = rhs.position;\n          lhsLevel = PREC_COMP;\n          break;\n        }\n        case \"|\": {\n          if (str[innerPos + 1] === \"|\") {\n            if (level > PREC_OR || lhsLevel < PREC_OR)\n              break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n            if (rhs.type === \"error\")\n              return rhs;\n            marks = marks.concat(rhs.marks);\n            marks.unshift({ name: \"or\", position: startPos });\n            pos = rhs.position;\n            lhsLevel = PREC_OR;\n          } else {\n            if (level > 11 || lhsLevel < 11)\n              break loop;\n            let identPos = skipWS(str, innerPos + 1);\n            let identLen = parseRegex(str, identPos, IDENT);\n            if (!identLen)\n              return { type: \"error\", position: identPos };\n            pos = identPos + identLen;\n            if (str[pos] === \"(\" || str[pos] === \":\") {\n              let result = parseFuncCall(str, identPos, pos);\n              if (result.type === \"error\")\n                return result;\n              marks = marks.concat(result.marks);\n              marks.unshift({ name: \"pipecall\", position: startPos });\n              pos = result.position;\n              lhsLevel = 11;\n            }\n          }\n          break;\n        }\n        case \"&\": {\n          if (str[innerPos + 1] != \"&\")\n            break loop;\n          if (level > PREC_AND || lhsLevel < PREC_AND)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"and\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_AND;\n          break;\n        }\n        case \"!\": {\n          if (str[innerPos + 1] !== \"=\")\n            break loop;\n          if (level > PREC_COMP || lhsLevel < PREC_COMP)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks.unshift({ name: \"comp\", position: startPos });\n          marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\n          marks = marks.concat(rhs.marks);\n          pos = rhs.position;\n          lhsLevel = PREC_COMP;\n          break;\n        }\n        case \"d\": {\n          if (str.slice(innerPos, innerPos + 4) !== \"desc\")\n            break loop;\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)\n            break loop;\n          marks.unshift({ name: \"desc\", position: startPos });\n          pos = innerPos + 4;\n          lhsLevel = PREC_ORDER;\n          break;\n        }\n        case \"a\": {\n          if (str.slice(innerPos, innerPos + 3) !== \"asc\")\n            break loop;\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)\n            break loop;\n          marks.unshift({ name: \"asc\", position: startPos });\n          pos = innerPos + 3;\n          lhsLevel = PREC_ORDER;\n          break;\n        }\n        default: {\n          let ident = parseRegexStr(str, innerPos, IDENT);\n          switch (ident) {\n            case \"in\": {\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n                break loop;\n              pos = skipWS(str, innerPos + 2);\n              let isGroup = false;\n              if (str[pos] === \"(\") {\n                isGroup = true;\n                pos = skipWS(str, pos + 1);\n              }\n              let rangePos = pos;\n              let result = parseExpr(str, pos, PREC_COMP + 1);\n              if (result.type === \"error\")\n                return result;\n              pos = skipWS(str, result.position);\n              if (str[pos] === \".\" && str[pos + 1] === \".\") {\n                let type = \"inc_range\";\n                if (str[pos + 2] === \".\") {\n                  type = \"exc_range\";\n                  pos = skipWS(str, pos + 3);\n                } else {\n                  pos = skipWS(str, pos + 2);\n                }\n                let rhs = parseExpr(str, pos, PREC_COMP + 1);\n                if (rhs.type === \"error\")\n                  return rhs;\n                marks.unshift({ name: \"in_range\", position: startPos });\n                marks = marks.concat({ name: type, position: rangePos }, result.marks, rhs.marks);\n                pos = rhs.position;\n              } else {\n                marks.unshift({ name: \"comp\", position: startPos });\n                marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\n                marks = marks.concat(result.marks);\n              }\n              if (isGroup) {\n                pos = skipWS(str, pos);\n                if (str[pos] !== \")\")\n                  return { type: \"error\", position: pos };\n                pos++;\n              }\n              lhsLevel = PREC_COMP;\n              break;\n            }\n            case \"match\": {\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks.unshift({ name: \"comp\", position: startPos });\n              marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 5 });\n              marks = marks.concat(rhs.marks);\n              pos = rhs.position;\n              lhsLevel = 4;\n              break;\n            }\n            default: {\n              break loop;\n            }\n          }\n        }\n      }\n    }\n  let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\n  return { type: \"success\", marks, position: pos, failPosition };\n}\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case \".\": {\n      pos = skipWS(str, pos + 1);\n      let identStart = pos;\n      let identLen2 = parseRegex(str, pos, IDENT);\n      if (!identLen2)\n        return { type: \"error\", position: pos };\n      pos += identLen2;\n      return {\n        type: \"success\",\n        marks: [\n          { name: \"attr_access\", position: startPos },\n          { name: \"ident\", position: identStart },\n          { name: \"ident_end\", position: pos }\n        ],\n        position: pos\n      };\n    }\n    case \"-\":\n      if (str[pos + 1] !== \">\")\n        return { type: \"error\", position: pos };\n      let marks = [{ name: \"deref\", position: startPos }];\n      pos += 2;\n      let identPos = skipWS(str, pos);\n      let identLen = parseRegex(str, identPos, IDENT);\n      if (identLen) {\n        pos = identPos + identLen;\n        marks.push({ name: \"deref_attr\", position: identPos }, { name: \"ident\", position: identPos }, { name: \"ident_end\", position: pos });\n      }\n      return {\n        type: \"success\",\n        marks,\n        position: pos\n      };\n    case \"[\": {\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === \"]\") {\n        return {\n          type: \"success\",\n          marks: [{ name: \"array_postfix\", position: startPos }],\n          position: pos + 1\n        };\n      }\n      let rangePos = pos;\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\")\n        return result;\n      pos = skipWS(str, result.position);\n      if (str[pos] === \".\" && str[pos + 1] === \".\") {\n        let type = \"inc_range\";\n        if (str[pos + 2] === \".\") {\n          type = \"exc_range\";\n          pos += 3;\n        } else {\n          pos += 2;\n        }\n        pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        if (rhs.type === \"error\")\n          return rhs;\n        pos = skipWS(str, rhs.position);\n        if (str[pos] !== \"]\")\n          return { type: \"error\", position: pos };\n        return {\n          type: \"success\",\n          marks: [\n            { name: \"slice\", position: startPos },\n            { name: type, position: rangePos }\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1\n        };\n      }\n      if (str[pos] !== \"]\")\n        return { type: \"error\", position: pos };\n      return {\n        type: \"success\",\n        marks: [{ name: \"square_bracket\", position: startPos }].concat(result.marks),\n        position: pos + 1\n      };\n    }\n    case \"|\": {\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === \"{\") {\n        let result = parseObject(str, pos);\n        if (result.type === \"error\")\n          return result;\n        result.marks.unshift({ name: \"projection\", position: startPos });\n        return result;\n      }\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      if (result.type === \"error\")\n        return result;\n      result.marks.unshift({ name: \"projection\", position: startPos });\n      return result;\n    }\n  }\n  return { type: \"error\", position: pos };\n}\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n  marks.push({ name: \"func_call\", position: startPos });\n  if (str[pos] === \":\" && str[pos + 1] === \":\") {\n    marks.push({ name: \"namespace\", position: startPos });\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos });\n    pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen)\n      return { type: \"error\", position: pos };\n    marks.push({ name: \"ident\", position: pos }, { name: \"ident_end\", position: pos + nameLen });\n    pos = skipWS(str, pos + nameLen);\n    if (str[pos] !== \"(\")\n      return { type: \"error\", position: pos };\n    pos++;\n  } else {\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos });\n    pos = skipWS(str, pos + 1);\n  }\n  let lastPos = pos;\n  if (str[pos] !== \")\") {\n    while (true) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\")\n        return result;\n      marks = marks.concat(result.marks);\n      lastPos = result.position;\n      pos = skipWS(str, result.position);\n      if (str[pos] !== \",\")\n        break;\n      pos = skipWS(str, pos + 1);\n    }\n  }\n  if (str[pos] !== \")\") {\n    return { type: \"error\", position: pos };\n  }\n  marks.push({ name: \"func_args_end\", position: lastPos });\n  return {\n    type: \"success\",\n    marks,\n    position: pos + 1\n  };\n}\nfunction parseObject(str, pos) {\n  let marks = [{ name: \"object\", position: pos }];\n  pos = skipWS(str, pos + 1);\n  loop:\n    while (str[pos] !== \"}\") {\n      let pairPos = pos;\n      switch (str[pos]) {\n        case '\"':\n        case \"'\": {\n          let field = parseString(str, pos);\n          if (field.type === \"error\")\n            return field;\n          pos = skipWS(str, field.position);\n          if (str[pos] !== \":\")\n            return { type: \"error\", position: pos };\n          let value = parseExpr(str, skipWS(str, pos + 1), 0);\n          if (value.type === \"error\")\n            return value;\n          marks.push({ name: \"object_pair\", position: pairPos });\n          marks = marks.concat(field.marks, value.marks);\n          pos = value.position;\n          break;\n        }\n        case \".\": {\n          if (str.slice(pos, pos + 3) === \"...\") {\n            pos = skipWS(str, pos + 3);\n            if (str[pos] !== \"}\" && str[pos] !== \",\") {\n              let expr = parseExpr(str, pos, 0);\n              if (expr.type === \"error\")\n                return expr;\n              marks.push({ name: \"object_splat\", position: pairPos });\n              marks = marks.concat(expr.marks);\n              pos = expr.position;\n              break;\n            } else {\n              marks.push({ name: \"object_splat_this\", position: pairPos });\n              break;\n            }\n          }\n          break loop;\n        }\n        default: {\n          let expr = parseExpr(str, pos, 0);\n          if (expr.type === \"error\")\n            return expr;\n          marks = marks.concat({ name: \"object_expr\", position: pos }, expr.marks);\n          pos = expr.position;\n        }\n      }\n      pos = skipWS(str, pos);\n      if (str[pos] !== \",\")\n        break;\n      pos = skipWS(str, pos + 1);\n    }\n  if (str[pos] !== \"}\") {\n    return { type: \"error\", position: pos };\n  }\n  pos++;\n  marks.push({ name: \"object_end\", position: pos });\n  return { type: \"success\", marks, position: pos };\n}\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{ name: \"str\", position: pos }];\n  str:\n    for (; ; pos++) {\n      if (pos > str.length)\n        return { type: \"error\", position: pos };\n      switch (str[pos]) {\n        case token: {\n          marks.push({ name: \"str_end\", position: pos });\n          pos++;\n          break str;\n        }\n        case \"\\\\\": {\n          marks.push({ name: \"str_pause\", position: pos });\n          if (str[pos + 1] === \"u\") {\n            if (str[pos + 2] === \"{\") {\n              marks.push({ name: \"unicode_hex\", position: pos + 3 });\n              pos = str.indexOf(\"}\", pos + 3);\n              marks.push({ name: \"unicode_hex_end\", position: pos });\n              pos++;\n            } else {\n              marks.push({ name: \"unicode_hex\", position: pos + 2 });\n              marks.push({ name: \"unicode_hex_end\", position: pos + 6 });\n              pos += 5;\n            }\n          } else {\n            marks.push({ name: \"single_escape\", position: pos + 1 });\n            pos += 1;\n          }\n          marks.push({ name: \"str_start\", position: pos + 1 });\n        }\n      }\n    }\n  return { type: \"success\", marks, position: pos };\n}\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null;\n}\nfunction join(a, b) {\n  return (base) => b(a(base));\n}\nfunction map(inner) {\n  return (base) => ({ type: \"Map\", base, expr: inner({ type: \"This\" }) });\n}\nfunction flatMap(inner) {\n  return (base) => ({ type: \"FlatMap\", base, expr: inner({ type: \"This\" }) });\n}\nfunction traverseArray(build, right) {\n  if (!right) {\n    return {\n      type: \"a-a\",\n      build\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(build, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"a-a\",\n        build: join(build, map(right.build))\n      };\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, flatMap(right.build))\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traversePlain(mapper, right) {\n  if (!right) {\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseElement(mapper, right) {\n  if (!right) {\n    return {\n      type: \"a-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"a-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseProjection(mapper, right) {\n  if (!right) {\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(map(mapper), right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(map(mapper), right.build)\n      };\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nconst isEqual = equality;\nfunction equality(a, b) {\n  if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\") {\n    return a.data === b.data;\n  }\n  if (a.type === \"datetime\" && b.type === \"datetime\") {\n    return a.data.equals(b.data);\n  }\n  return false;\n}\nconst operators = {\n  \"==\": function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"!=\": function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n  },\n  \">\": function gt(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \">=\": function gte(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<\": function lt(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<=\": function lte(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  in: async function inop(left, right) {\n    if (right.type === \"path\") {\n      if (left.type !== \"string\") {\n        return NULL_VALUE;\n      }\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n    }\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE;\n        }\n      }\n      return FALSE_VALUE;\n    }\n    return NULL_VALUE;\n  },\n  match: async function match(left, right) {\n    let tokens = [];\n    let patterns = [];\n    await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part));\n    });\n    const didSucceed = await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part));\n    });\n    if (!didSucceed) {\n      return FALSE_VALUE;\n    }\n    const matched = matchText(tokens, patterns);\n    return matched ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"+\": function plus(left, right) {\n    if (left.type === \"datetime\" && right.type === \"number\") {\n      return fromDateTime(left.data.add(right.data));\n    }\n    if (left.type === \"number\" && right.type === \"number\") {\n      return fromNumber(left.data + right.data);\n    }\n    if (left.type === \"string\" && right.type === \"string\") {\n      return fromString(left.data + right.data);\n    }\n    if (left.type === \"object\" && right.type === \"object\") {\n      return fromJS(__spreadValues(__spreadValues({}, left.data), right.data));\n    }\n    if (left.type === \"array\" && right.type === \"array\") {\n      return fromJS(left.data.concat(right.data));\n    }\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val;\n        }\n        for await (const val of right) {\n          yield val;\n        }\n      });\n    }\n    return NULL_VALUE;\n  },\n  \"-\": function minus(left, right) {\n    if (left.type === \"datetime\" && right.type === \"number\") {\n      return fromDateTime(left.data.add(-right.data));\n    }\n    if (left.type === \"datetime\" && right.type === \"datetime\") {\n      return fromNumber(left.data.difference(right.data));\n    }\n    if (left.type === \"number\" && right.type === \"number\") {\n      return fromNumber(left.data - right.data);\n    }\n    return NULL_VALUE;\n  },\n  \"*\": numericOperator((a, b) => a * b),\n  \"/\": numericOperator((a, b) => a / b),\n  \"%\": numericOperator((a, b) => a % b),\n  \"**\": numericOperator((a, b) => Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n  return function(left, right) {\n    if (left.type === \"number\" && right.type === \"number\") {\n      const result = impl(left.data, right.data);\n      return fromNumber(result);\n    }\n    return NULL_VALUE;\n  };\n}\nclass Scope {\n  constructor(params, source, value, context, parent) {\n    this.isHidden = false;\n    this.params = params;\n    this.source = source;\n    this.value = value;\n    this.context = context;\n    this.parent = parent;\n  }\n  createNested(value) {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent);\n    }\n    return new Scope(this.params, this.source, value, this.context, this);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    result.isHidden = true;\n    return result;\n  }\n}\nfunction evaluate(node, scope, execute = evaluate) {\n  const func = EXECUTORS[node.type];\n  return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n  if (\"then\" in value) {\n    return value.then(cb);\n  }\n  return cb(value);\n}\nconst EXECUTORS = {\n  This(_, scope) {\n    return scope.value;\n  },\n  Everything(_, scope) {\n    return scope.source;\n  },\n  Parameter({ name }, scope) {\n    return fromJS(scope.params[name]);\n  },\n  Context({ key }, scope) {\n    if (key === \"before\" || key === \"after\") {\n      const value = scope.context[key];\n      return value || NULL_VALUE;\n    }\n    throw new Error(`unknown context key: ${key}`);\n  },\n  Parent({ n }, scope) {\n    let current = scope;\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE;\n      }\n      current = current.parent;\n    }\n    return current.value;\n  },\n  OpCall({ op, left, right }, scope, execute) {\n    const func = operators[op];\n    if (!func) {\n      throw new Error(`Unknown operator: ${op}`);\n    }\n    const leftValue = execute(left, scope);\n    const rightValue = execute(right, scope);\n    if (\"then\" in leftValue || \"then\" in rightValue) {\n      return (async () => func(await leftValue, await rightValue))();\n    }\n    return func(leftValue, rightValue);\n  },\n  async Select({ alternatives, fallback }, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope);\n      if (altCond.type === \"boolean\" && altCond.data === true) {\n        return execute(alt.value, scope);\n      }\n    }\n    if (fallback) {\n      return execute(fallback, scope);\n    }\n    return NULL_VALUE;\n  },\n  async InRange({ base, left, right, isInclusive }, scope, execute) {\n    const value = await execute(base, scope);\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    const leftCmp = partialCompare(await value.get(), await leftValue.get());\n    if (leftCmp === null) {\n      return NULL_VALUE;\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get());\n    if (rightCmp === null) {\n      return NULL_VALUE;\n    }\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    }\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  async Filter({ base, expr }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem);\n        const exprValue = await execute(expr, newScope);\n        if (exprValue.type === \"boolean\" && exprValue.data === true) {\n          yield elem;\n        }\n      }\n    });\n  },\n  async Projection({ base, expr }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (baseValue.type !== \"object\") {\n      return NULL_VALUE;\n    }\n    const newScope = scope.createNested(baseValue);\n    return execute(expr, newScope);\n  },\n  FuncCall({ func, args }, scope, execute) {\n    return func(args, scope, execute);\n  },\n  async PipeFuncCall({ func, base, args }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    return func(baseValue, args, scope, execute);\n  },\n  async AccessAttribute({ base, name }, scope, execute) {\n    let value = scope.value;\n    if (base) {\n      value = await execute(base, scope);\n    }\n    if (value.type === \"object\") {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name]);\n      }\n    }\n    return NULL_VALUE;\n  },\n  async AccessElement({ base, index }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    const data = await baseValue.get();\n    const finalIndex = index < 0 ? index + data.length : index;\n    return fromJS(data[finalIndex]);\n  },\n  async Slice({ base, left, right, isInclusive }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    const array = await baseValue.get();\n    let leftIdx = left;\n    let rightIdx = right;\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx;\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx;\n    }\n    if (isInclusive) {\n      rightIdx++;\n    }\n    if (leftIdx < 0) {\n      leftIdx = 0;\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0;\n    }\n    return fromJS(array.slice(leftIdx, rightIdx));\n  },\n  async Deref({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    if (!scope.source.isArray()) {\n      return NULL_VALUE;\n    }\n    if (value.type !== \"object\") {\n      return NULL_VALUE;\n    }\n    const id = value.data._ref;\n    if (typeof id !== \"string\") {\n      return NULL_VALUE;\n    }\n    for await (const doc of scope.source) {\n      if (doc.type === \"object\" && id === doc.data._id) {\n        return doc;\n      }\n    }\n    return NULL_VALUE;\n  },\n  Value({ value }) {\n    return fromJS(value);\n  },\n  Group({ base }, scope, execute) {\n    return execute(base, scope);\n  },\n  async Object({ attributes }, scope, execute) {\n    const result = {};\n    for (const attr of attributes) {\n      const attrType = attr.type;\n      switch (attr.type) {\n        case \"ObjectAttributeValue\": {\n          const value = await execute(attr.value, scope);\n          result[attr.name] = await value.get();\n          break;\n        }\n        case \"ObjectConditionalSplat\": {\n          const cond = await execute(attr.condition, scope);\n          if (cond.type !== \"boolean\" || cond.data === false) {\n            continue;\n          }\n          const value = await execute(attr.value, scope);\n          if (value.type === \"object\") {\n            Object.assign(result, value.data);\n          }\n          break;\n        }\n        case \"ObjectSplat\": {\n          const value = await execute(attr.value, scope);\n          if (value.type === \"object\") {\n            Object.assign(result, value.data);\n          }\n          break;\n        }\n        default:\n          throw new Error(`Unknown node type: ${attrType}`);\n      }\n    }\n    return fromJS(result);\n  },\n  Array({ elements }, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope);\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v;\n            }\n          }\n        } else {\n          yield value;\n        }\n      }\n    });\n  },\n  Tuple() {\n    throw new Error(\"tuples can not be evaluated\");\n  },\n  async Or({ left, right }, scope, execute) {\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    if (leftValue.type === \"boolean\") {\n      if (leftValue.data === true) {\n        return TRUE_VALUE;\n      }\n    }\n    if (rightValue.type === \"boolean\") {\n      if (rightValue.data === true) {\n        return TRUE_VALUE;\n      }\n    }\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return FALSE_VALUE;\n  },\n  async And({ left, right }, scope, execute) {\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    if (leftValue.type === \"boolean\") {\n      if (leftValue.data === false) {\n        return FALSE_VALUE;\n      }\n    }\n    if (rightValue.type === \"boolean\") {\n      if (rightValue.data === false) {\n        return FALSE_VALUE;\n      }\n    }\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return TRUE_VALUE;\n  },\n  async Not({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    if (value.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE;\n  },\n  Neg({ base }, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== \"number\") {\n        return NULL_VALUE;\n      }\n      return fromNumber(-value.data);\n    });\n  },\n  Pos({ base }, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== \"number\") {\n        return NULL_VALUE;\n      }\n      return fromNumber(value.data);\n    });\n  },\n  Asc() {\n    return NULL_VALUE;\n  },\n  Desc() {\n    return NULL_VALUE;\n  },\n  async ArrayCoerce({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    return value.isArray() ? value : NULL_VALUE;\n  },\n  async Map({ base, expr }, scope, execute) {\n    const value = await execute(base, scope);\n    if (!value.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        yield await execute(expr, newScope);\n      }\n    });\n  },\n  async FlatMap({ base, expr }, scope, execute) {\n    const value = await execute(base, scope);\n    if (!value.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        const innerValue = await execute(expr, newScope);\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner;\n          }\n        } else {\n          yield innerValue;\n        }\n      }\n    });\n  }\n};\nfunction evaluateQuery(tree, options = {}) {\n  const root = fromJS(options.root);\n  const dataset = fromJS(options.dataset);\n  const params = __spreadValues({}, options.params);\n  const scope = new Scope(params, dataset, root, {\n    timestamp: options.timestamp || new Date(),\n    identity: options.identity === void 0 ? \"me\" : options.identity,\n    sanity: options.sanity,\n    after: options.after ? fromJS(options.after) : null,\n    before: options.before ? fromJS(options.before) : null\n  }, null);\n  return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n  switch (node.type) {\n    case \"Group\":\n    case \"Value\":\n    case \"Parameter\":\n    case \"Pos\":\n    case \"Neg\":\n      return true;\n    case \"OpCall\":\n      switch (node.op) {\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"**\":\n          return true;\n        default:\n          return false;\n      }\n    default:\n      return false;\n  }\n}\nconst DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, { timestamp: new Date(0), identity: \"me\", before: null, after: null }, null);\nclass ConstantEvaluateError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"ConstantEvaluateError\";\n  }\n}\nfunction tryConstantEvaluate(node) {\n  try {\n    return constantEvaluate(node);\n  } catch (err) {\n    if (err.name === \"ConstantEvaluateError\") {\n      return null;\n    }\n    throw err;\n  }\n}\nfunction constantEvaluate(node) {\n  if (!canConstantEvaluate(node)) {\n    throw new ConstantEvaluateError(\"cannot constant evaluate\");\n  }\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n  if (\"then\" in value) {\n    throw new Error(\"BUG: constant evaluate should never return a promise\");\n  }\n  return value;\n}\nconst ESCAPE_SEQUENCE = {\n  \"'\": \"'\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n  b: \"\\b\",\n  f: \"\\f\",\n  n: \"\\n\",\n  r: \"\\r\",\n  t: \"\t\"\n};\nfunction expandHex(str) {\n  const charCode = parseInt(str, 16);\n  return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"GroqQueryError\";\n  }\n}\nconst EXPR_BUILDER = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER);\n    return {\n      type: \"Group\",\n      base: inner\n    };\n  },\n  everything() {\n    return { type: \"Everything\" };\n  },\n  this() {\n    return { type: \"This\" };\n  },\n  parent() {\n    return {\n      type: \"Parent\",\n      n: 1\n    };\n  },\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER);\n    return {\n      type: \"Parent\",\n      n: next.n + 1\n    };\n  },\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER);\n    const traversalList = [];\n    while (p.getMark().name !== \"traversal_end\") {\n      traversalList.push(p.process(TRAVERSE_BUILDER));\n    }\n    p.shift();\n    let traversal = null;\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal);\n    }\n    if (base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") {\n      traversal = traverseArray((val) => val, traversal);\n    }\n    if (traversal === null)\n      throw new Error(\"BUG: unexpected empty traversal\");\n    return traversal.build(base);\n  },\n  this_attr(p) {\n    const name = p.processString();\n    if (name === \"null\") {\n      return { type: \"Value\", value: null };\n    }\n    if (name === \"true\") {\n      return { type: \"Value\", value: true };\n    }\n    if (name === \"false\") {\n      return { type: \"Value\", value: false };\n    }\n    return {\n      type: \"AccessAttribute\",\n      name\n    };\n  },\n  neg(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Neg\",\n      base\n    };\n  },\n  pos(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Pos\",\n      base\n    };\n  },\n  add(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"+\",\n      left,\n      right\n    };\n  },\n  sub(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"-\",\n      left,\n      right\n    };\n  },\n  mul(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"*\",\n      left,\n      right\n    };\n  },\n  div(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"/\",\n      left,\n      right\n    };\n  },\n  mod(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"%\",\n      left,\n      right\n    };\n  },\n  pow(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"**\",\n      left,\n      right\n    };\n  },\n  comp(p) {\n    const left = p.process(EXPR_BUILDER);\n    const op = p.processString();\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op,\n      left,\n      right\n    };\n  },\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER);\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"InRange\",\n      base,\n      left,\n      right,\n      isInclusive\n    };\n  },\n  str(p) {\n    let value = \"\";\n    loop:\n      while (p.hasMark()) {\n        const mark = p.getMark();\n        switch (mark.name) {\n          case \"str_end\":\n            value += p.processStringEnd();\n            break loop;\n          case \"str_pause\":\n            value += p.processStringEnd();\n            break;\n          case \"str_start\":\n            p.shift();\n            break;\n          case \"single_escape\": {\n            const char = p.slice(1);\n            p.shift();\n            value += ESCAPE_SEQUENCE[char];\n            break;\n          }\n          case \"unicode_hex\":\n            p.shift();\n            value += expandHex(p.processStringEnd());\n            break;\n          default:\n            throw new Error(`unexpected mark: ${mark.name}`);\n        }\n      }\n    return { type: \"Value\", value };\n  },\n  integer(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  float(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  sci(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  object(p) {\n    const attributes = [];\n    while (p.getMark().name !== \"object_end\") {\n      attributes.push(p.process(OBJECT_BUILDER));\n    }\n    p.shift();\n    return {\n      type: \"Object\",\n      attributes\n    };\n  },\n  array(p) {\n    const elements = [];\n    while (p.getMark().name !== \"array_end\") {\n      let isSplat = false;\n      if (p.getMark().name === \"array_splat\") {\n        isSplat = true;\n        p.shift();\n      }\n      const value = p.process(EXPR_BUILDER);\n      elements.push({\n        type: \"ArrayElement\",\n        value,\n        isSplat\n      });\n    }\n    p.shift();\n    return {\n      type: \"Array\",\n      elements\n    };\n  },\n  tuple(p) {\n    const members = [];\n    while (p.getMark().name !== \"tuple_end\") {\n      members.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    return {\n      type: \"Tuple\",\n      members\n    };\n  },\n  func_call(p) {\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\") {\n      p.shift();\n      namespace = p.processString();\n    }\n    const name = p.processString();\n    if (namespace === \"global\" && name === \"select\") {\n      const result = {\n        type: \"Select\",\n        alternatives: []\n      };\n      while (p.getMark().name !== \"func_args_end\") {\n        if (p.getMark().name === \"pair\") {\n          if (result.fallback)\n            throw new GroqQueryError(`unexpected argument to select()`);\n          p.shift();\n          const condition = p.process(EXPR_BUILDER);\n          const value = p.process(EXPR_BUILDER);\n          result.alternatives.push({\n            type: \"SelectAlternative\",\n            condition,\n            value\n          });\n        } else {\n          if (result.fallback)\n            throw new GroqQueryError(`unexpected argument to select()`);\n          const value = p.process(EXPR_BUILDER);\n          result.fallback = value;\n        }\n      }\n      p.shift();\n      return result;\n    }\n    const args = [];\n    while (p.getMark().name !== \"func_args_end\") {\n      args.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    if (namespace === \"global\" && (name === \"before\" || name === \"after\")) {\n      if (p.parseOptions.mode === \"delta\") {\n        return {\n          type: \"Context\",\n          key: name\n        };\n      }\n    }\n    if (namespace === \"global\" && name === \"boost\" && !p.allowBoost)\n      throw new GroqQueryError(\"unexpected boost\");\n    const funcs = namespaces[namespace];\n    if (!funcs) {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    }\n    const func = funcs[name];\n    if (!func) {\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    }\n    if (func.arity !== void 0) {\n      validateArity(name, func.arity, args.length);\n    }\n    if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    }\n    return {\n      type: \"FuncCall\",\n      func,\n      name,\n      args\n    };\n  },\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER);\n    p.shift();\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\") {\n      p.shift();\n      namespace = p.processString();\n    }\n    if (namespace !== \"global\") {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    }\n    const name = p.processString();\n    const args = [];\n    const oldAllowBoost = p.allowBoost;\n    if (name === \"score\") {\n      p.allowBoost = true;\n    }\n    for (; ; ) {\n      const markName = p.getMark().name;\n      if (markName === \"func_args_end\") {\n        break;\n      }\n      if (name === \"order\") {\n        if (markName === \"asc\") {\n          p.shift();\n          args.push({ type: \"Asc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        } else if (markName === \"desc\") {\n          p.shift();\n          args.push({ type: \"Desc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        }\n      }\n      args.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    p.allowBoost = oldAllowBoost;\n    const func = pipeFunctions[name];\n    if (!func) {\n      throw new GroqQueryError(`Undefined pipe function: ${name}`);\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length);\n    }\n    return {\n      type: \"PipeFuncCall\",\n      func,\n      base,\n      name,\n      args\n    };\n  },\n  pair(p) {\n    throw new GroqQueryError(`unexpected =>`);\n  },\n  and(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"And\",\n      left,\n      right\n    };\n  },\n  or(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"Or\",\n      left,\n      right\n    };\n  },\n  not(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Not\",\n      base\n    };\n  },\n  asc(p) {\n    throw new GroqQueryError(\"unexpected asc\");\n  },\n  desc(p) {\n    throw new GroqQueryError(\"unexpected desc\");\n  },\n  param(p) {\n    const name = p.processString();\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: \"Value\",\n        value: p.parseOptions.params[name]\n      };\n    }\n    return {\n      type: \"Parameter\",\n      name\n    };\n  }\n};\nconst OBJECT_BUILDER = {\n  object_expr(p) {\n    if (p.getMark().name === \"pair\") {\n      p.shift();\n      const condition = p.process(EXPR_BUILDER);\n      const value2 = p.process(EXPR_BUILDER);\n      return {\n        type: \"ObjectConditionalSplat\",\n        condition,\n        value: value2\n      };\n    }\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: extractPropertyKey(value),\n      value\n    };\n  },\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER);\n    if (name.type !== \"Value\")\n      throw new Error(\"name must be string\");\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: name.value,\n      value\n    };\n  },\n  object_splat(p) {\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectSplat\",\n      value\n    };\n  },\n  object_splat_this() {\n    return {\n      type: \"ObjectSplat\",\n      value: { type: \"This\" }\n    };\n  }\n};\nconst TRAVERSE_BUILDER = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER);\n    const value = tryConstantEvaluate(expr);\n    if (value && value.type === \"number\") {\n      return (right) => traverseElement((base) => ({ type: \"AccessElement\", base, index: value.data }), right);\n    }\n    if (value && value.type === \"string\") {\n      return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name: value.data }), right);\n    }\n    return (right) => traverseArray((base) => ({\n      type: \"Filter\",\n      base,\n      expr\n    }), right);\n  },\n  slice(p) {\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    const leftValue = tryConstantEvaluate(left);\n    const rightValue = tryConstantEvaluate(right);\n    if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") {\n      throw new GroqQueryError(\"slicing must use constant numbers\");\n    }\n    return (rhs) => traverseArray((base) => ({\n      type: \"Slice\",\n      base,\n      left: leftValue.data,\n      right: rightValue.data,\n      isInclusive\n    }), rhs);\n  },\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER);\n    return (right) => traverseProjection((base) => ({ type: \"Projection\", base, expr: obj }), right);\n  },\n  attr_access(p) {\n    const name = p.processString();\n    return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name }), right);\n  },\n  deref(p) {\n    let attr = null;\n    if (p.getMark().name === \"deref_attr\") {\n      p.shift();\n      attr = p.processString();\n    }\n    const wrap = (base) => attr ? { type: \"AccessAttribute\", base, name: attr } : base;\n    return (right) => traversePlain((base) => wrap({\n      type: \"Deref\",\n      base\n    }), right);\n  },\n  array_postfix(p) {\n    return (right) => traverseArray((base) => ({ type: \"ArrayCoerce\", base }), right);\n  }\n};\nfunction extractPropertyKey(node) {\n  if (node.type === \"AccessAttribute\" && !node.base) {\n    return node.name;\n  }\n  if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\") {\n    return extractPropertyKey(node.base);\n  }\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);\n}\nfunction validateArity(name, arity, count2) {\n  if (typeof arity === \"number\") {\n    if (count2 !== arity) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count2}.`);\n    }\n  } else if (arity) {\n    if (!arity(count2)) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);\n    }\n  }\n}\nclass GroqSyntaxError extends Error {\n  constructor(position) {\n    super(`Syntax error in GROQ query at position ${position}`);\n    this.name = \"GroqSyntaxError\";\n    this.position = position;\n  }\n}\nfunction parse(input, options = {}) {\n  const result = parse$1(input);\n  if (result.type === \"error\") {\n    throw new GroqSyntaxError(result.position);\n  }\n  const processor = new MarkProcessor(input, result.marks, options);\n  return processor.process(EXPR_BUILDER);\n}\n\n//# sourceMappingURL=groq-js.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZ3JvcS1zdG9yZS9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0L2dyb3EtanMuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxJQUFJLEVBQUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0EsWUFBWSxLQUFLLEdBQUcsTUFBTSxHQUFHLElBQUksR0FBRyxLQUFLLEdBQUcsT0FBTyxHQUFHLE9BQU8sRUFBRSxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxHQUFHO0FBQ3RDLGdEQUFnRCxHQUFHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsb0RBQW9EO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQ0FBbUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlDQUFpQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0NBQW9DO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0NBQWtDO0FBQ3ZELFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RDtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBd0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQyxZQUFZLHVDQUF1QztBQUNuRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZELGdCQUFnQixtQ0FBbUM7QUFDbkQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEUsMkJBQTJCLGdDQUFnQyxJQUFJLHdDQUF3QztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVELHVCQUF1QixnQ0FBZ0MsSUFBSSxtQ0FBbUM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQ0FBaUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RCx1QkFBdUIsZ0NBQWdDLElBQUksd0NBQXdDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQ0FBc0M7QUFDdEUsdUNBQXVDLGdDQUFnQztBQUN2RTtBQUNBLGdCQUFnQjtBQUNoQixnQ0FBZ0Msa0NBQWtDO0FBQ2xFLDZCQUE2QixnQ0FBZ0MsSUFBSSx3Q0FBd0M7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRSwyQkFBMkIsZ0NBQWdDLElBQUksd0NBQXdDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUNBQXlDO0FBQ3JELFlBQVkscUNBQXFDO0FBQ2pELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdDQUF3QyxJQUFJLG1DQUFtQyxJQUFJLGtDQUFrQztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUEyQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsNENBQTRDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdDQUF3QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0NBQXdDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RDtBQUNBLGlCQUFpQix1Q0FBdUM7QUFDeEQsaUJBQWlCLG1DQUFtQyxJQUFJLGtDQUFrQztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCLDhCQUE4QixJQUFJLDRDQUE0QztBQUMvRjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQixtQ0FBbUMsSUFBSSxrQ0FBa0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWUsMENBQTBDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0NBQXdDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5Q0FBeUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDJCQUEyQiw4Q0FBOEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9DQUFvQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBLGFBQWE7QUFDYjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQSxtQ0FBbUM7QUFDbkMsMkJBQTJCLHdDQUF3QztBQUNuRSxrQ0FBa0M7QUFDbEMsMkJBQTJCLHdDQUF3QztBQUNuRTtBQUNBLGNBQWM7QUFDZCwyQkFBMkIsd0NBQXdDO0FBQ25FLDJCQUEyQiw0Q0FBNEM7QUFDdkU7QUFDQTtBQUNBLFlBQVk7QUFDWix5QkFBeUIsMENBQTBDO0FBQ25FO0FBQ0E7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUMsY0FBYyxHQUFHO0FBQ3hFO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDLGNBQWMsR0FBRztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxNQUFNO0FBQ3BCO0FBQ0EsR0FBRztBQUNILFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hELEdBQUc7QUFDSCxXQUFXLEdBQUc7QUFDZDtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0EsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxhQUFhLFlBQVk7QUFDekI7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNILDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVUsT0FBTztBQUNqQjtBQUNBLEdBQUc7QUFDSCxVQUFVLE1BQU07QUFDaEI7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEIsbUVBQW1FO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFVBQVU7QUFDakU7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxVQUFVO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUE0QztBQUNsRTtBQUNBLFVBQVU7QUFDVjtBQUNBLHNCQUFzQiw2Q0FBNkM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdEQUFnRDtBQUNyRztBQUNBO0FBQ0EsbURBQW1ELGlEQUFpRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNEQUFzRCxxQ0FBcUM7QUFDM0YsR0FBRztBQUNIO0FBQ0E7QUFDQSxpREFBaUQscUNBQXFDO0FBQ3RGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNENBQTRDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxpREFBaUQsMkJBQTJCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxVQUFVO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLEtBQUssZUFBZSxNQUFNLFFBQVEsT0FBTztBQUNySDtBQUNBLElBQUk7QUFDSjtBQUNBLDRFQUE0RSxLQUFLO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUM1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZ3JvcS1zdG9yZS9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0L2dyb3EtanMuZXNtLmpzPzdiMGQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY2xhc3MgTWFya1Byb2Nlc3NvciB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZzMsIG1hcmtzLCBwYXJzZU9wdGlvbnMpIHtcbiAgICB0aGlzLmFsbG93Qm9vc3QgPSBmYWxzZTtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZzM7XG4gICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMucGFyc2VPcHRpb25zID0gcGFyc2VPcHRpb25zO1xuICB9XG4gIGhhc01hcmsocG9zID0gMCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4ICsgcG9zIDwgdGhpcy5tYXJrcy5sZW5ndGg7XG4gIH1cbiAgZ2V0TWFyayhwb3MgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMubWFya3NbdGhpcy5pbmRleCArIHBvc107XG4gIH1cbiAgc2hpZnQoKSB7XG4gICAgdGhpcy5pbmRleCArPSAxO1xuICB9XG4gIHByb2Nlc3ModmlzaXRvcikge1xuICAgIGNvbnN0IG1hcmsgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHRoaXMuc2hpZnQoKTtcbiAgICBjb25zdCBmdW5jID0gdmlzaXRvclttYXJrLm5hbWVdO1xuICAgIGlmICghZnVuYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGhhbmRsZXI6ICR7bWFyay5uYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5jYWxsKHZpc2l0b3IsIHRoaXMsIG1hcmspO1xuICB9XG4gIHByb2Nlc3NTdHJpbmcoKSB7XG4gICAgdGhpcy5zaGlmdCgpO1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nRW5kKCkge1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXggLSAxXTtcbiAgICBjb25zdCBjdXJyID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHByZXYucG9zaXRpb24sIGN1cnIucG9zaXRpb24pO1xuICB9XG4gIHNsaWNlKGxlbikge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMubWFya3NbdGhpcy5pbmRleF0ucG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHBvcywgcG9zICsgbGVuKTtcbiAgfVxufVxuY29uc3QgUkZDMzMzOV9SRUdFWCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkKyk/KFp8KFstK11cXGR7Mn06XFxkezJ9KSkkLztcbmZ1bmN0aW9uIHBhcnNlUkZDMzMzOShzdHIpIHtcbiAgaWYgKFJGQzMzMzlfUkVHRVgudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHN0cik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmb3JtYXRSRkMzMzM5KGQpIHtcbiAgY29uc3QgeWVhciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRnVsbFllYXIoKSwgNCk7XG4gIGNvbnN0IG1vbnRoID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNb250aCgpICsgMSwgMik7XG4gIGNvbnN0IGRheSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRGF0ZSgpLCAyKTtcbiAgY29uc3QgaG91ciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDSG91cnMoKSwgMik7XG4gIGNvbnN0IG1pbnV0ZSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTWludXRlcygpLCAyKTtcbiAgY29uc3Qgc2Vjb25kID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENTZWNvbmRzKCksIDIpO1xuICBsZXQgZnJhY3Rpb25hbFNlY29uZCA9IFwiXCI7XG4gIGNvbnN0IG1pbGxpcyA9IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIGlmIChtaWxsaXMgIT0gMCkge1xuICAgIGZyYWN0aW9uYWxTZWNvbmQgPSBgLiR7YWRkTGVhZGluZ1plcm8obWlsbGlzLCAzKX1gO1xuICB9XG4gIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1UJHtob3VyfToke21pbnV0ZX06JHtzZWNvbmR9JHtmcmFjdGlvbmFsU2Vjb25kfVpgO1xufVxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm8obnVtLCB0YXJnZXRMZW5ndGgpIHtcbiAgbGV0IHN0ciA9IG51bS50b1N0cmluZygpO1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgIHN0ciA9IGAwJHtzdHJ9YDtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZzMpIHtcbiAgcmV0dXJuIHN0cmluZzMucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gcGF0aFJlZ0V4cChwYXR0ZXJuKSB7XG4gIGNvbnN0IHJlID0gW107XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXR0ZXJuLnNwbGl0KFwiLlwiKSkge1xuICAgIGlmIChwYXJ0ID09PSBcIipcIikge1xuICAgICAgcmUucHVzaChcIlteLl0rXCIpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXCIqKlwiKSB7XG4gICAgICByZS5wdXNoKFwiLipcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlLnB1c2goZXNjYXBlUmVnRXhwKHBhcnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlLmpvaW4oXCIuXCIpfSRgKTtcbn1cbmNsYXNzIFBhdGgge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICB0aGlzLnBhdHRlcm5SZSA9IHBhdGhSZWdFeHAocGF0dGVybik7XG4gIH1cbiAgbWF0Y2hlcyhzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuUmUudGVzdChzdHIpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xuICB9XG59XG5jbGFzcyBTdHJlYW1WYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKGdlbmVyYXRvcikge1xuICAgIHRoaXMudHlwZSA9IFwic3RyZWFtXCI7XG4gICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgdGhpcy50aWNrZXIgPSBudWxsO1xuICAgIHRoaXMuaXNEb25lID0gZmFsc2U7XG4gICAgdGhpcy5kYXRhID0gW107XG4gIH1cbiAgaXNBcnJheSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhc3luYyBnZXQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzKSB7XG4gICAgICByZXN1bHQucHVzaChhd2FpdCB2YWx1ZS5nZXQoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBmb3IgKDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB5aWVsZCB0aGlzLmRhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0RvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5fbmV4dFRpY2soKTtcbiAgICB9XG4gIH1cbiAgX25leHRUaWNrKCkge1xuICAgIGlmICh0aGlzLnRpY2tlcikge1xuICAgICAgcmV0dXJuIHRoaXMudGlja2VyO1xuICAgIH1cbiAgICBsZXQgY3VycmVudFJlc29sdmVyO1xuICAgIGNvbnN0IHNldHVwVGlja2VyID0gKCkgPT4ge1xuICAgICAgdGhpcy50aWNrZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjdXJyZW50UmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB0aWNrID0gKCkgPT4ge1xuICAgICAgY3VycmVudFJlc29sdmVyKCk7XG4gICAgICBzZXR1cFRpY2tlcigpO1xuICAgIH07XG4gICAgY29uc3QgZmV0Y2ggPSBhc3luYyAoKSA9PiB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHRoaXMuZ2VuZXJhdG9yKCkpIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICAgICAgICB0aWNrKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmlzRG9uZSA9IHRydWU7XG4gICAgICB0aWNrKCk7XG4gICAgfTtcbiAgICBzZXR1cFRpY2tlcigpO1xuICAgIGZldGNoKCk7XG4gICAgcmV0dXJuIHRoaXMudGlja2VyO1xuICB9XG59XG5jbGFzcyBTdGF0aWNWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHR5cGUpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cbiAgaXNBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBcImFycmF5XCI7XG4gIH1cbiAgYXN5bmMgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qIChkYXRhKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBkYXRhKSB7XG4gICAgICAgICAgeWllbGQgZnJvbUpTKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9KHRoaXMuZGF0YSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGl0ZXJhdGUgb3ZlcjogJHt0aGlzLnR5cGV9YCk7XG4gIH1cbn1cbmNvbnN0IE5VTExfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUobnVsbCwgXCJudWxsXCIpO1xuY29uc3QgVFJVRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZSh0cnVlLCBcImJvb2xlYW5cIik7XG5jb25zdCBGQUxTRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShmYWxzZSwgXCJib29sZWFuXCIpO1xuY2xhc3MgRGF0ZVRpbWUge1xuICBjb25zdHJ1Y3RvcihkYXRlKSB7XG4gICAgdGhpcy5kYXRlID0gZGF0ZTtcbiAgfVxuICBzdGF0aWMgcGFyc2VUb1ZhbHVlKHN0cikge1xuICAgIGNvbnN0IGRhdGUgPSBwYXJzZVJGQzMzMzkoc3RyKTtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShuZXcgRGF0ZVRpbWUoZGF0ZSksIFwiZGF0ZXRpbWVcIik7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpID09IG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIGFkZChzZWNzKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRUaW1lKCkpO1xuICAgIGNvcHkuc2V0VGltZShjb3B5LmdldFRpbWUoKSArIHNlY3MgKiAxZTMpO1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoY29weSk7XG4gIH1cbiAgZGlmZmVyZW5jZShvdGhlcikge1xuICAgIHJldHVybiAodGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpKSAvIDFlMztcbiAgfVxuICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBmb3JtYXRSRkMzMzM5KHRoaXMuZGF0ZSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21OdW1iZXIobnVtKSB7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUobnVtKSkge1xuICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUobnVtLCBcIm51bWJlclwiKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoc3RyLCBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21EYXRlVGltZShkdCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKGR0LCBcImRhdGV0aW1lXCIpO1xufVxuZnVuY3Rpb24gZnJvbVBhdGgocGF0aDIpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShwYXRoMiwgXCJwYXRoXCIpO1xufVxuZnVuY3Rpb24gaXNJdGVyYXRvcihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLm5leHQgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGZyb21KUyh2YWwpIHtcbiAgaWYgKGlzSXRlcmF0b3IodmFsKSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdmFsKSB7XG4gICAgICAgIHlpZWxkIGZyb21KUyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZSh2YWwsIGdldFR5cGUodmFsKSk7XG59XG5mdW5jdGlvbiBnZXRUeXBlKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwgfHwgdHlwZW9mIGRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgUGF0aCkge1xuICAgIHJldHVybiBcInBhdGhcIjtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGVUaW1lKSB7XG4gICAgcmV0dXJuIFwiZGF0ZXRpbWVcIjtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGRhdGE7XG59XG5jb25zdCBUWVBFX09SREVSID0ge1xuICBkYXRldGltZTogMSxcbiAgbnVtYmVyOiAyLFxuICBzdHJpbmc6IDMsXG4gIGJvb2xlYW46IDRcbn07XG5mdW5jdGlvbiBwYXJ0aWFsQ29tcGFyZShhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKTtcbiAgY29uc3QgYlR5cGUgPSBnZXRUeXBlKGIpO1xuICBpZiAoYVR5cGUgIT09IGJUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3dpdGNoIChhVHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGlmIChhIDwgYilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKGEgPiBiKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgcmV0dXJuIGEuY29tcGFyZVRvKGIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gdG90YWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpO1xuICBjb25zdCBiVHlwZSA9IGdldFR5cGUoYik7XG4gIGNvbnN0IGFUeXBlT3JkZXIgPSBUWVBFX09SREVSW2FUeXBlXSB8fCAxMDA7XG4gIGNvbnN0IGJUeXBlT3JkZXIgPSBUWVBFX09SREVSW2JUeXBlXSB8fCAxMDA7XG4gIGlmIChhVHlwZU9yZGVyICE9PSBiVHlwZU9yZGVyKSB7XG4gICAgcmV0dXJuIGFUeXBlT3JkZXIgLSBiVHlwZU9yZGVyO1xuICB9XG4gIGxldCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShhLCBiKTtcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIHJlc3VsdCA9IDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IENIQVJTID0gLyhbXiFAIyQlXiYqKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2c7XG5jb25zdCBDSEFSU19XSVRIX1dJTERDQVJEID0gLyhbXiFAIyQlXiYoKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZztcbmNvbnN0IEVER0VfQ0hBUlMgPSAvKFxcYlxcLit8XFwuK1xcYikvZztcbmNvbnN0IE1BWF9URVJNX0xFTkdUSCA9IDEwMjQ7XG5mdW5jdGlvbiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykge1xuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCBwYXR0ZXJucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHBhdHRlcm5zLmV2ZXJ5KChwYXR0ZXJuKSA9PiBwYXR0ZXJuKHRva2VucykpO1xufVxuZnVuY3Rpb24gbWF0Y2hUb2tlbml6ZSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlMpIHx8IFtdO1xufVxuZnVuY3Rpb24gbWF0Y2hBbmFseXplUGF0dGVybih0ZXh0KSB7XG4gIGNvbnN0IHRlcm1zUmUgPSBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0KTtcbiAgcmV0dXJuIHRlcm1zUmUubWFwKChyZSkgPT4gKHRva2VucykgPT4gdG9rZW5zLnNvbWUoKHRva2VuKSA9PiByZS50ZXN0KHRva2VuKSkpO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCkge1xuICBjb25zdCB0ZXJtcyA9IHRleHQucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSU19XSVRIX1dJTERDQVJEKSB8fCBbXTtcbiAgcmV0dXJuIHRlcm1zLm1hcCgodGVybSkgPT4gbmV3IFJlZ0V4cChgXiR7dGVybS5zbGljZSgwLCBNQVhfVEVSTV9MRU5HVEgpLnJlcGxhY2UoL1xcKi9nLCBcIi4qXCIpfSRgLCBcImlcIikpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2F0aGVyVGV4dCh2YWx1ZSwgY2IpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjYih2YWx1ZS5kYXRhKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiB2YWx1ZSkge1xuICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjYihwYXJ0LmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBCTTI1ayA9IDEuMjtcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlU2NvcmUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcENhbGxcIiAmJiBub2RlLm9wID09PSBcIm1hdGNoXCIpIHtcbiAgICByZXR1cm4gZXZhbHVhdGVNYXRjaFNjb3JlKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiRnVuY0NhbGxcIiAmJiBub2RlLm5hbWUgPT09IFwiYm9vc3RcIikge1xuICAgIGNvbnN0IGlubmVyU2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUuYXJnc1swXSwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgIGNvbnN0IGJvb3N0MiA9IGF3YWl0IGV4ZWN1dGUobm9kZS5hcmdzWzFdLCBzY29wZSk7XG4gICAgaWYgKGJvb3N0Mi50eXBlID09PSBcIm51bWJlclwiICYmIGlubmVyU2NvcmUgPiAwKSB7XG4gICAgICByZXR1cm4gaW5uZXJTY29yZSArIGJvb3N0Mi5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPclwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgY29uc3QgcmlnaHRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgcmV0dXJuIGxlZnRTY29yZSArIHJpZ2h0U2NvcmU7XG4gICAgfVxuICAgIGNhc2UgXCJBbmRcIjoge1xuICAgICAgY29uc3QgbGVmdFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLmxlZnQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgIGNvbnN0IHJpZ2h0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgIGlmIChsZWZ0U2NvcmUgPT09IDAgfHwgcmlnaHRTY29yZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZXhlY3V0ZShub2RlLCBzY29wZSk7XG4gICAgICByZXR1cm4gcmVzLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlcy5kYXRhID09PSB0cnVlID8gMSA6IDA7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZU1hdGNoU2NvcmUobGVmdCwgcmlnaHQsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHRleHQgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgY29uc3QgcGF0dGVybiA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgbGV0IHRva2VucyA9IFtdO1xuICBsZXQgdGVybXMgPSBbXTtcbiAgYXdhaXQgZ2F0aGVyVGV4dCh0ZXh0LCAocGFydCkgPT4ge1xuICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShwYXJ0KSk7XG4gIH0pO1xuICBjb25zdCBkaWRTdWNjZWVkID0gYXdhaXQgZ2F0aGVyVGV4dChwYXR0ZXJuLCAocGFydCkgPT4ge1xuICAgIHRlcm1zID0gdGVybXMuY29uY2F0KG1hdGNoUGF0dGVyblJlZ2V4KHBhcnQpKTtcbiAgfSk7XG4gIGlmICghZGlkU3VjY2VlZCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRlcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBzY29yZTIgPSAwO1xuICBmb3IgKGNvbnN0IHJlIG9mIHRlcm1zKSB7XG4gICAgY29uc3QgZnJlcSA9IHRva2Vucy5yZWR1Y2UoKGMsIHRva2VuKSA9PiBjICsgKHJlLnRlc3QodG9rZW4pID8gMSA6IDApLCAwKTtcbiAgICBzY29yZTIgKz0gZnJlcSAqIChCTTI1ayArIDEpIC8gKGZyZXEgKyBCTTI1ayk7XG4gIH1cbiAgcmV0dXJuIHNjb3JlMjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gYmxvY2tUZXh0KHZhbHVlLmRhdGEpO1xuICB9IGVsc2UgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgIGNvbnN0IHRleHRzID0gYXdhaXQgYXJyYXlUZXh0KHZhbHVlKTtcbiAgICBpZiAodGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRleHRzLmpvaW4oXCJcXG5cXG5cIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gYXJyYXlUZXh0KHZhbHVlLCByZXN1bHQgPSBbXSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGJsb2NrIG9mIHZhbHVlKSB7XG4gICAgaWYgKGJsb2NrLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBibG9ja1RleHQoYmxvY2suZGF0YSk7XG4gICAgICBpZiAodGV4dCAhPT0gbnVsbClcbiAgICAgICAgcmVzdWx0LnB1c2godGV4dCk7XG4gICAgfSBlbHNlIGlmIChibG9jay5pc0FycmF5KCkpIHtcbiAgICAgIGF3YWl0IGFycmF5VGV4dChibG9jaywgcmVzdWx0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJsb2NrVGV4dChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmouX3R5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGNoaWxkcmVuID0gb2JqLmNoaWxkcmVuO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNoaWxkLl90eXBlID09PSBcInN0cmluZ1wiICYmIGNoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiB0eXBlb2YgY2hpbGQudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzdWx0ICs9IGNoaWxkLnRleHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBoYXNSZWZlcmVuY2UodmFsdWUsIHBhdGhTZXQpIHtcbiAgc3dpdGNoIChnZXRUeXBlKHZhbHVlKSkge1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKHZhbHVlLl9yZWYpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhTZXQuaGFzKHZhbHVlLl9yZWYpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2IG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRVVEY4KHN0cikge1xuICBsZXQgY291bnQyID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPj0gNTUyOTYgJiYgY29kZSA8PSA1NjMxOSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvdW50MisrO1xuICB9XG4gIHJldHVybiBjb3VudDI7XG59XG5jb25zdCBnbG9iYWwgPSB7fTtcbmdsb2JhbC5jb2FsZXNjZSA9IGFzeW5jIGZ1bmN0aW9uIGNvYWxlc2NlKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnLCBzY29wZSk7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVsbFwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbmdsb2JhbC5jb3VudCA9IGFzeW5jIGZ1bmN0aW9uIGNvdW50KGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghaW5uZXIuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgbGV0IG51bSA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xuICAgIG51bSsrO1xuICB9XG4gIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG59O1xuZ2xvYmFsLmNvdW50LmFyaXR5ID0gMTtcbmdsb2JhbC5kYXRlVGltZSA9IGFzeW5jIGZ1bmN0aW9uIGRhdGVUaW1lKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAodmFsLnR5cGUgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHZhbC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIERhdGVUaW1lLnBhcnNlVG9WYWx1ZSh2YWwuZGF0YSk7XG59O1xuZ2xvYmFsLmRhdGVUaW1lLmFyaXR5ID0gMTtcbmdsb2JhbC5kZWZpbmVkID0gYXN5bmMgZnVuY3Rpb24gZGVmaW5lZChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gaW5uZXIudHlwZSA9PT0gXCJudWxsXCIgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG59O1xuZ2xvYmFsLmRlZmluZWQuYXJpdHkgPSAxO1xuZ2xvYmFsLmlkZW50aXR5ID0gYXN5bmMgZnVuY3Rpb24gaWRlbnRpdHkoYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5pZGVudGl0eSk7XG59O1xuZ2xvYmFsLmlkZW50aXR5LmFyaXR5ID0gMDtcbmdsb2JhbC5sZW5ndGggPSBhc3luYyBmdW5jdGlvbiBsZW5ndGgoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKGlubmVyLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcihjb3VudFVURjgoaW5uZXIuZGF0YSkpO1xuICB9XG4gIGlmIChpbm5lci5pc0FycmF5KCkpIHtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgaW5uZXIpIHtcbiAgICAgIG51bSsrO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbU51bWJlcihudW0pO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbmdsb2JhbC5sZW5ndGguYXJpdHkgPSAxO1xuZ2xvYmFsLnBhdGggPSBhc3luYyBmdW5jdGlvbiBwYXRoKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmIChpbm5lci50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21QYXRoKG5ldyBQYXRoKGlubmVyLmRhdGEpKTtcbn07XG5nbG9iYWwucGF0aC5hcml0eSA9IDE7XG5nbG9iYWwuc3RyaW5nID0gYXN5bmMgZnVuY3Rpb24gc3RyaW5nKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKGAke3ZhbHVlLmRhdGF9YCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG59O1xuZ2xvYmFsLnN0cmluZy5hcml0eSA9IDE7XG5nbG9iYWwucmVmZXJlbmNlcyA9IGFzeW5jIGZ1bmN0aW9uIHJlZmVyZW5jZXMoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgcGF0aFNldCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGNvbnN0IHBhdGgyID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcbiAgICBpZiAocGF0aDIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGF0aFNldC5hZGQocGF0aDIuZGF0YSk7XG4gICAgfSBlbHNlIGlmIChwYXRoMi5pc0FycmF5KCkpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBwYXRoMikge1xuICAgICAgICBpZiAoZWxlbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcGF0aFNldC5hZGQoZWxlbS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocGF0aFNldC5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICB9XG4gIGNvbnN0IHNjb3BlVmFsdWUgPSBhd2FpdCBzY29wZS52YWx1ZS5nZXQoKTtcbiAgcmV0dXJuIGhhc1JlZmVyZW5jZShzY29wZVZhbHVlLCBwYXRoU2V0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbn07XG5nbG9iYWwucmVmZXJlbmNlcy5hcml0eSA9IChjKSA9PiBjID49IDE7XG5nbG9iYWwucm91bmQgPSBhc3luYyBmdW5jdGlvbiByb3VuZChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAodmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IG51bSA9IHZhbHVlLmRhdGE7XG4gIGxldCBwcmVjID0gMDtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgcHJlY1ZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gICAgaWYgKHByZWNWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHByZWNWYWx1ZS5kYXRhIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihwcmVjVmFsdWUuZGF0YSkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBwcmVjID0gcHJlY1ZhbHVlLmRhdGE7XG4gIH1cbiAgaWYgKHByZWMgPT09IDApIHtcbiAgICBpZiAobnVtIDwgMCkge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLU1hdGgucm91bmQoLW51bSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbU51bWJlcihNYXRoLnJvdW5kKG51bSkpO1xuICB9XG4gIHJldHVybiBmcm9tTnVtYmVyKE51bWJlcihudW0udG9GaXhlZChwcmVjKSkpO1xufTtcbmdsb2JhbC5yb3VuZC5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxICYmIGNvdW50MiA8PSAyO1xuZ2xvYmFsLm5vdyA9IGFzeW5jIGZ1bmN0aW9uIG5vdyhhcmdzLCBzY29wZSkge1xuICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnRpbWVzdGFtcC50b0lTT1N0cmluZygpKTtcbn07XG5nbG9iYWwubm93LmFyaXR5ID0gMDtcbmdsb2JhbC5ib29zdCA9IGFzeW5jIGZ1bmN0aW9uIGJvb3N0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0IGNhbGxcIik7XG59O1xuZ2xvYmFsLmJvb3N0LmFyaXR5ID0gMjtcbmNvbnN0IHN0cmluZzIgPSB7fTtcbnN0cmluZzIubG93ZXIgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAodmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9Mb3dlckNhc2UoKSk7XG59O1xuc3RyaW5nMi5sb3dlci5hcml0eSA9IDE7XG5zdHJpbmcyLnVwcGVyID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvVXBwZXJDYXNlKCkpO1xufTtcbnN0cmluZzIudXBwZXIuYXJpdHkgPSAxO1xuZ2xvYmFsLmxvd2VyID0gc3RyaW5nMi5sb3dlcjtcbmdsb2JhbC51cHBlciA9IHN0cmluZzIudXBwZXI7XG5jb25zdCBwdCA9IHt9O1xucHQudGV4dCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGNvbnN0IHRleHQgPSBhd2FpdCBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKTtcbiAgaWYgKHRleHQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVN0cmluZyh0ZXh0KTtcbn07XG5wdC50ZXh0LmFyaXR5ID0gMTtcbmNvbnN0IHNhbml0eSA9IHt9O1xuc2FuaXR5LnByb2plY3RJZCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XG4gIGlmIChzY29wZS5jb250ZXh0LnNhbml0eSkge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LnByb2plY3RJZCk7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuc2FuaXR5LmRhdGFzZXQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSkge1xuICBpZiAoc2NvcGUuY29udGV4dC5zYW5pdHkpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5kYXRhc2V0KTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5jb25zdCBwaXBlRnVuY3Rpb25zID0ge307XG5waXBlRnVuY3Rpb25zLm9yZGVyID0gYXN5bmMgZnVuY3Rpb24gb3JkZXIoYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgYXdhaXQgdHJ1ZTtcbiAgaWYgKCFiYXNlLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IG1hcHBlcnMgPSBbXTtcbiAgY29uc3QgZGlyZWN0aW9ucyA9IFtdO1xuICBsZXQgbiA9IDA7XG4gIGZvciAobGV0IG1hcHBlciBvZiBhcmdzKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IFwiYXNjXCI7XG4gICAgaWYgKG1hcHBlci50eXBlID09PSBcIkRlc2NcIikge1xuICAgICAgZGlyZWN0aW9uID0gXCJkZXNjXCI7XG4gICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlci50eXBlID09PSBcIkFzY1wiKSB7XG4gICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICB9XG4gICAgbWFwcGVycy5wdXNoKG1hcHBlcik7XG4gICAgZGlyZWN0aW9ucy5wdXNoKGRpcmVjdGlvbik7XG4gICAgbisrO1xuICB9XG4gIGNvbnN0IGF1eCA9IFtdO1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBiYXNlKSB7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIGNvbnN0IHR1cGxlID0gW2F3YWl0IHZhbHVlLmdldCgpLCBpZHhdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlKG1hcHBlcnNbaV0sIG5ld1Njb3BlKTtcbiAgICAgIHR1cGxlLnB1c2goYXdhaXQgcmVzdWx0LmdldCgpKTtcbiAgICB9XG4gICAgYXV4LnB1c2godHVwbGUpO1xuICAgIGlkeCsrO1xuICB9XG4gIGF1eC5zb3J0KChhVHVwbGUsIGJUdXBsZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsZXQgYyA9IHRvdGFsQ29tcGFyZShhVHVwbGVbaSArIDJdLCBiVHVwbGVbaSArIDJdKTtcbiAgICAgIGlmIChkaXJlY3Rpb25zW2ldID09PSBcImRlc2NcIikge1xuICAgICAgICBjID0gLWM7XG4gICAgICB9XG4gICAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFUdXBsZVsxXSAtIGJUdXBsZVsxXTtcbiAgfSk7XG4gIHJldHVybiBmcm9tSlMoYXV4Lm1hcCgodikgPT4gdlswXSkpO1xufTtcbnBpcGVGdW5jdGlvbnMub3JkZXIuYXJpdHkgPSAoY291bnQyKSA9PiBjb3VudDIgPj0gMTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUgPSBhc3luYyBmdW5jdGlvbiBzY29yZShiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBpZiAoIWJhc2UuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCB1bmtub3duID0gW107XG4gIGNvbnN0IHNjb3JlZCA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdW5rbm93bi5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgbGV0IHZhbHVlU2NvcmUgPSB0eXBlb2YgdmFsdWUuZGF0YS5fc2NvcmUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS5kYXRhLl9zY29yZSA6IDA7XG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgdmFsdWVTY29yZSArPSBhd2FpdCBldmFsdWF0ZVNjb3JlKGFyZywgbmV3U2NvcGUsIGV4ZWN1dGUpO1xuICAgIH1cbiAgICBjb25zdCBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZS5kYXRhLCB7IF9zY29yZTogdmFsdWVTY29yZSB9KTtcbiAgICBzY29yZWQucHVzaChuZXdPYmplY3QpO1xuICB9XG4gIHNjb3JlZC5zb3J0KChhLCBiKSA9PiBiLl9zY29yZSAtIGEuX3Njb3JlKTtcbiAgcmV0dXJuIGZyb21KUyhzY29yZWQpO1xufTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUuYXJpdHkgPSAoY291bnQyKSA9PiBjb3VudDIgPj0gMTtcbmNvbnN0IGRlbHRhID0ge307XG5kZWx0YS5vcGVyYXRpb24gPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSkge1xuICBjb25zdCBoYXNCZWZvcmUgPSBzY29wZS5jb250ZXh0LmJlZm9yZSAhPT0gbnVsbDtcbiAgY29uc3QgaGFzQWZ0ZXIgPSBzY29wZS5jb250ZXh0LmFmdGVyICE9PSBudWxsO1xuICBpZiAoaGFzQmVmb3JlICYmIGhhc0FmdGVyKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJ1cGRhdGVcIik7XG4gIH1cbiAgaWYgKGhhc0FmdGVyKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJjcmVhdGVcIik7XG4gIH1cbiAgaWYgKGhhc0JlZm9yZSkge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKFwiZGVsZXRlXCIpO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kZWx0YS5jaGFuZ2VkQW55LmFyaXR5ID0gMTtcbmRlbHRhLmNoYW5nZWRBbnkubW9kZSA9IFwiZGVsdGFcIjtcbmRlbHRhLmNoYW5nZWRPbmx5ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGVsdGEuY2hhbmdlZE9ubHkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZE9ubHkubW9kZSA9IFwiZGVsdGFcIjtcbmNvbnN0IGRpZmYgPSB7fTtcbmRpZmYuY2hhbmdlZEFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRpZmYuY2hhbmdlZEFueS5hcml0eSA9IDM7XG5kaWZmLmNoYW5nZWRPbmx5ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGlmZi5jaGFuZ2VkT25seS5hcml0eSA9IDM7XG5jb25zdCBuYW1lc3BhY2VzID0ge1xuICBnbG9iYWwsXG4gIHN0cmluZzogc3RyaW5nMixcbiAgcHQsXG4gIGRlbHRhLFxuICBkaWZmLFxuICBzYW5pdHlcbn07XG5jb25zdCBXUyA9IC9eKFtcXHRcXG5cXHZcXGZcXHIgXFx1MDA4NVxcdTAwQTBdfChcXC9cXC9bXlxcbl0rXFxuKSkrLztcbmNvbnN0IE5VTSA9IC9eXFxkKy87XG5jb25zdCBJREVOVCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKi87XG5jb25zdCBQUkVDX1BBSVIgPSAxO1xuY29uc3QgUFJFQ19PUiA9IDI7XG5jb25zdCBQUkVDX0FORCA9IDM7XG5jb25zdCBQUkVDX0NPTVAgPSA0O1xuY29uc3QgUFJFQ19PUkRFUiA9IDQ7XG5jb25zdCBQUkVDX0FERCA9IDY7XG5jb25zdCBQUkVDX1NVQiA9IDY7XG5jb25zdCBQUkVDX01VTCA9IDc7XG5jb25zdCBQUkVDX0RJViA9IDc7XG5jb25zdCBQUkVDX01PRCA9IDc7XG5jb25zdCBQUkVDX1BPVyA9IDg7XG5jb25zdCBQUkVDX1BPUyA9IDEwO1xuY29uc3QgUFJFQ19OT1QgPSAxMDtcbmNvbnN0IFBSRUNfTkVHID0gODtcbmZ1bmN0aW9uIHBhcnNlJDEoc3RyKSB7XG4gIGxldCBwb3MgPSAwO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcbiAgaWYgKHBvcyAhPT0gc3RyLmxlbmd0aCkge1xuICAgIGlmIChyZXN1bHQuZmFpbFBvc2l0aW9uKSB7XG4gICAgICBwb3MgPSByZXN1bHQuZmFpbFBvc2l0aW9uIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gIH1cbiAgZGVsZXRlIHJlc3VsdC5wb3NpdGlvbjtcbiAgZGVsZXRlIHJlc3VsdC5mYWlsUG9zaXRpb247XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyLCBwb3MsIGxldmVsKSB7XG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIGxldCBtYXJrcztcbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19QT1MpO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwicG9zXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiLVwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfTkVHKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcIm5lZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIihcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAwKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJ0dXBsZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidHVwbGVfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIilcIjoge1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJncm91cFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiIVwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfTk9UKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcIm5vdFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIntcIjoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJhcnJheVwiLCBwb3NpdGlvbjogcG9zIH1dO1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiXVwiKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShwb3MsIHBvcyArIDMpID09PSBcIi4uLlwiKSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJhcnJheV9zcGxhdFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByZXMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICAgIGlmIChyZXMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXMubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHJlcy5wb3NpdGlvbjtcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIsXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJ1wiOlxuICAgIGNhc2UgJ1wiJzoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlU3RyaW5nKHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIl5cIjoge1xuICAgICAgcG9zKys7XG4gICAgICBtYXJrcyA9IFtdO1xuICAgICAgd2hpbGUgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiXlwiKSB7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImRibHBhcmVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgIHBvcyArPSAyO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwicGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiQFwiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInRoaXNcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiKlwiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcImV2ZXJ5dGhpbmdcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJFwiOiB7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zICsgMSwgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyArPSAxICsgaWRlbnRMZW47XG4gICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgIHsgbmFtZTogXCJwYXJhbVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zICsgMSB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGV0IG51bUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICBpZiAobnVtTGVuKSB7XG4gICAgICAgIHBvcyArPSBudW1MZW47XG4gICAgICAgIGxldCBuYW1lID0gXCJpbnRlZ2VyXCI7XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xuICAgICAgICAgIGlmIChmcmFjTGVuKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJmbG9hdFwiO1xuICAgICAgICAgICAgcG9zICs9IDEgKyBmcmFjTGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiZVwiIHx8IHN0cltwb3NdID09PSBcIkVcIikge1xuICAgICAgICAgIG5hbWUgPSBcInNjaVwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIrXCIgfHwgc3RyW3Bvc10gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGV4cExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICAgICAgaWYgKCFleHBMZW4pXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICBwb3MgKz0gZXhwTGVuO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgIHsgbmFtZSwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgeyBuYW1lOiBuYW1lICsgXCJfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICBwb3MgKz0gaWRlbnRMZW47XG4gICAgICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOlxuICAgICAgICAgIGNhc2UgXCIoXCI6IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzO1xuICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgICAgICB7IG5hbWU6IFwidGhpc19hdHRyXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFtYXJrcykge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICB9XG4gIGxldCBsaHNMZXZlbCA9IDEyO1xuICBsZXQgdHJhdjtcbiAgbG9vcDpcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IGlubmVyUG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgIGlmIChpbm5lclBvcyA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICBwb3MgPSBpbm5lclBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBpbm5lclBvcyk7XG4gICAgICBpZiAodHJhdi50eXBlID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJ0cmF2ZXJzZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgIHdoaWxlICh0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQodHJhdi5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gdHJhdi5wb3NpdGlvbjtcbiAgICAgICAgICB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBza2lwV1Moc3RyLCBwb3MpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0cmF2ZXJzYWxfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IHRva2VuMiA9IHN0cltpbm5lclBvc107XG4gICAgICBzd2l0Y2ggKHRva2VuMikge1xuICAgICAgICBjYXNlIFwiPVwiOiB7XG4gICAgICAgICAgbGV0IG5leHRUb2tlbiA9IHN0cltpbm5lclBvcyArIDFdO1xuICAgICAgICAgIHN3aXRjaCAobmV4dFRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOiB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUEFJUiB8fCBsaHNMZXZlbCA8PSBQUkVDX1BBSVIpXG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfUEFJUik7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBhaXJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QQUlSO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUClcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNSk7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pO1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0FERCB8fCBsaHNMZXZlbCA8IFBSRUNfQUREKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19BREQgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhZGRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQUREO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCItXCI6IHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1NVQiB8fCBsaHNMZXZlbCA8IFBSRUNfU1VCKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19TVUIgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJzdWJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfU1VCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIqXCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1BPVyB8fCBsaHNMZXZlbCA8PSBQUkVDX1BPVylcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMyID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QT1cpO1xuICAgICAgICAgICAgaWYgKHJoczIudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmhzMjtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJoczIubWFya3MpO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicG93XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICAgIHBvcyA9IHJoczIucG9zaXRpb247XG4gICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfUE9XO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTVVMIHx8IGxoc0xldmVsIDwgUFJFQ19NVUwpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX01VTCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm11bFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19NVUw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi9cIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfRElWIHx8IGxoc0xldmVsIDwgUFJFQ19ESVYpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0RJViArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRpdlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19ESVY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIiVcIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTU9EIHx8IGxoc0xldmVsIDwgUFJFQ19NT0QpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX01PRCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm1vZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19NT0Q7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgY2FzZSBcIj5cIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCBuZXh0UG9zID0gaW5uZXJQb3MgKyAxO1xuICAgICAgICAgIGlmIChzdHJbbmV4dFBvc10gPT09IFwiPVwiKSB7XG4gICAgICAgICAgICBuZXh0UG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBuZXh0UG9zIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ8XCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwifFwiKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SIHx8IGxoc0xldmVsIDwgUFJFQ19PUilcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX09SICsgMSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJvclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1I7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDExIHx8IGxoc0xldmVsIDwgMTEpXG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpO1xuICAgICAgICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICAgICAgICBpZiAoIWlkZW50TGVuKVxuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9O1xuICAgICAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIoXCIgfHwgc3RyW3Bvc10gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgaWRlbnRQb3MsIHBvcyk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBpcGVjYWxsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgICBsaHNMZXZlbCA9IDExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiJlwiOiB7XG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9IFwiJlwiKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0FORCB8fCBsaHNMZXZlbCA8IFBSRUNfQU5EKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19BTkQgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhbmRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQU5EO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT09IFwiPVwiKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPCBQUkVDX0NPTVApXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KTtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZFwiOiB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyA0KSAhPT0gXCJkZXNjXCIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1JERVIgfHwgbGhzTGV2ZWwgPCBQUkVDX09SREVSKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJkZXNjXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSBpbm5lclBvcyArIDQ7XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhXCI6IHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDMpICE9PSBcImFzY1wiKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SREVSIHx8IGxoc0xldmVsIDwgUFJFQ19PUkRFUilcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiYXNjXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSBpbm5lclBvcyArIDM7XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBsZXQgaWRlbnQgPSBwYXJzZVJlZ2V4U3RyKHN0ciwgaW5uZXJQb3MsIElERU5UKTtcbiAgICAgICAgICBzd2l0Y2ggKGlkZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwiaW5cIjoge1xuICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKVxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMik7XG4gICAgICAgICAgICAgIGxldCBpc0dyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICBpc0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XG4gICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImV4Y19yYW5nZVwiO1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiaW5fcmFuZ2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHsgbmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zIH0sIHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1hdGNoXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUClcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyA1KSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyA1IH0pO1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBsZXQgZmFpbFBvc2l0aW9uID0gKHRyYXYgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYXYudHlwZSkgPT09IFwiZXJyb3JcIiAmJiB0cmF2LnBvc2l0aW9uO1xuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MsIGZhaWxQb3NpdGlvbiB9O1xufVxuZnVuY3Rpb24gcGFyc2VUcmF2ZXJzYWwoc3RyLCBwb3MpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgY2FzZSBcIi5cIjoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBsZXQgaWRlbnRTdGFydCA9IHBvcztcbiAgICAgIGxldCBpZGVudExlbjIgPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICBpZiAoIWlkZW50TGVuMilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBwb3MgKz0gaWRlbnRMZW4yO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzOiBbXG4gICAgICAgICAgeyBuYW1lOiBcImF0dHJfYWNjZXNzXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogaWRlbnRTdGFydCB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF0sXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCItXCI6XG4gICAgICBpZiAoc3RyW3BvcyArIDFdICE9PSBcIj5cIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcImRlcmVmXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XTtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW47XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImRlcmVmX2F0dHJcIiwgcG9zaXRpb246IGlkZW50UG9zIH0sIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9O1xuICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIG1hcmtzOiBbeyBuYW1lOiBcImFycmF5X3Bvc3RmaXhcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgdHlwZSA9IFwiZXhjX3JhbmdlXCI7XG4gICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XG4gICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCJdXCIpXG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJzbGljZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgIHsgbmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zIH1cbiAgICAgICAgICBdLmNvbmNhdChyZXN1bHQubWFya3MsIHJocy5tYXJrcyksXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCJdXCIpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzOiBbeyBuYW1lOiBcInNxdWFyZV9icmFja2V0XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmVzdWx0Lm1hcmtzKSxcbiAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ8XCI6IHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIntcIikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIntcIjoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInByb2plY3Rpb25cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG59XG5mdW5jdGlvbiBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcykge1xuICBsZXQgbWFya3MgPSBbXTtcbiAgbWFya3MucHVzaCh7IG5hbWU6IFwiZnVuY19jYWxsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgaWYgKHN0cltwb3NdID09PSBcIjpcIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiOlwiKSB7XG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwibmFtZXNwYWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgIGxldCBuYW1lTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgIGlmICghbmFtZUxlbilcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBwb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgbmFtZUxlbiB9KTtcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyBuYW1lTGVuKTtcbiAgICBpZiAoc3RyW3Bvc10gIT09IFwiKFwiKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgcG9zKys7XG4gIH0gZWxzZSB7XG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgfVxuICBsZXQgbGFzdFBvcyA9IHBvcztcbiAgaWYgKHN0cltwb3NdICE9PSBcIilcIikge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgIGxhc3RQb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIixcIilcbiAgICAgICAgYnJlYWs7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0cltwb3NdICE9PSBcIilcIikge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICB9XG4gIG1hcmtzLnB1c2goeyBuYW1lOiBcImZ1bmNfYXJnc19lbmRcIiwgcG9zaXRpb246IGxhc3RQb3MgfSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgbWFya3MsXG4gICAgcG9zaXRpb246IHBvcyArIDFcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KHN0ciwgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFt7IG5hbWU6IFwib2JqZWN0XCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICBsb29wOlxuICAgIHdoaWxlIChzdHJbcG9zXSAhPT0gXCJ9XCIpIHtcbiAgICAgIGxldCBwYWlyUG9zID0gcG9zO1xuICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgIGNhc2UgXCInXCI6IHtcbiAgICAgICAgICBsZXQgZmllbGQgPSBwYXJzZVN0cmluZyhzdHIsIHBvcyk7XG4gICAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBmaWVsZC5wb3NpdGlvbik7XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIjpcIilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAwKTtcbiAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9wYWlyXCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGZpZWxkLm1hcmtzLCB2YWx1ZS5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gdmFsdWUucG9zaXRpb247XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi5cIjoge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIikge1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwifVwiICYmIHN0cltwb3NdICE9PSBcIixcIikge1xuICAgICAgICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3NwbGF0XCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKTtcbiAgICAgICAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3Rfc3BsYXRfdGhpc1wiLCBwb3NpdGlvbjogcGFpclBvcyB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IFwib2JqZWN0X2V4cHJcIiwgcG9zaXRpb246IHBvcyB9LCBleHByLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIixcIilcbiAgICAgICAgYnJlYWs7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICB9XG4gIGlmIChzdHJbcG9zXSAhPT0gXCJ9XCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgfVxuICBwb3MrKztcbiAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0ciwgcG9zKSB7XG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xuICBwb3MgPSBwb3MgKyAxO1xuICBjb25zdCBtYXJrcyA9IFt7IG5hbWU6IFwic3RyXCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gIHN0cjpcbiAgICBmb3IgKDsgOyBwb3MrKykge1xuICAgICAgaWYgKHBvcyA+IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICBjYXNlIHRva2VuOiB7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGJyZWFrIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiXFxcXFwiOiB7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX3BhdXNlXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgaWYgKHN0cltwb3MgKyAxXSA9PT0gXCJ1XCIpIHtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4XCIsIHBvc2l0aW9uOiBwb3MgKyAzIH0pO1xuICAgICAgICAgICAgICBwb3MgPSBzdHIuaW5kZXhPZihcIn1cIiwgcG9zICsgMyk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4XCIsIHBvc2l0aW9uOiBwb3MgKyAyIH0pO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleF9lbmRcIiwgcG9zaXRpb246IHBvcyArIDYgfSk7XG4gICAgICAgICAgICAgIHBvcyArPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzaW5nbGVfZXNjYXBlXCIsIHBvc2l0aW9uOiBwb3MgKyAxIH0pO1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9zdGFydFwiLCBwb3NpdGlvbjogcG9zICsgMSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zIH07XG59XG5mdW5jdGlvbiBza2lwV1Moc3RyLCBwb3MpIHtcbiAgcmV0dXJuIHBvcyArIHBhcnNlUmVnZXgoc3RyLCBwb3MsIFdTKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXgoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXS5sZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleFN0cihzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGpvaW4oYSwgYikge1xuICByZXR1cm4gKGJhc2UpID0+IGIoYShiYXNlKSk7XG59XG5mdW5jdGlvbiBtYXAoaW5uZXIpIHtcbiAgcmV0dXJuIChiYXNlKSA9PiAoeyB0eXBlOiBcIk1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xufVxuZnVuY3Rpb24gZmxhdE1hcChpbm5lcikge1xuICByZXR1cm4gKGJhc2UpID0+ICh7IHR5cGU6IFwiRmxhdE1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VBcnJheShidWlsZCwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgYnVpbGRcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgbWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIGZsYXRNYXAocmlnaHQuYnVpbGQpKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQbGFpbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlRWxlbWVudChtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUHJvamVjdGlvbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuY29uc3QgaXNFcXVhbCA9IGVxdWFsaXR5O1xuZnVuY3Rpb24gZXF1YWxpdHkoYSwgYikge1xuICBpZiAoYS50eXBlID09PSBcInN0cmluZ1wiICYmIGIudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBhLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGIudHlwZSA9PT0gXCJib29sZWFuXCIgfHwgYS50eXBlID09PSBcIm51bGxcIiAmJiBiLnR5cGUgPT09IFwibnVsbFwiIHx8IGEudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBiLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gYS5kYXRhID09PSBiLmRhdGE7XG4gIH1cbiAgaWYgKGEudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIGIudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgcmV0dXJuIGEuZGF0YS5lcXVhbHMoYi5kYXRhKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBvcGVyYXRvcnMgPSB7XG4gIFwiPT1cIjogZnVuY3Rpb24gZXEobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiIT1cIjogZnVuY3Rpb24gbmVxKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICB9LFxuICBcIj5cIjogZnVuY3Rpb24gZ3QobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0ID4gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI+PVwiOiBmdW5jdGlvbiBndGUobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0ID49IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPFwiOiBmdW5jdGlvbiBsdChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjw9XCI6IGZ1bmN0aW9uIGx0ZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPD0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgaW46IGFzeW5jIGZ1bmN0aW9uIGlub3AobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAocmlnaHQudHlwZSA9PT0gXCJwYXRoXCIpIHtcbiAgICAgIGlmIChsZWZ0LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmlnaHQuZGF0YS5tYXRjaGVzKGxlZnQuZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIGlmIChyaWdodC5pc0FycmF5KCkpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgYiBvZiByaWdodCkge1xuICAgICAgICBpZiAoaXNFcXVhbChsZWZ0LCBiKSkge1xuICAgICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBtYXRjaDogYXN5bmMgZnVuY3Rpb24gbWF0Y2gobGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgbGV0IHBhdHRlcm5zID0gW107XG4gICAgYXdhaXQgZ2F0aGVyVGV4dChsZWZ0LCAocGFydCkgPT4ge1xuICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcbiAgICB9KTtcbiAgICBjb25zdCBkaWRTdWNjZWVkID0gYXdhaXQgZ2F0aGVyVGV4dChyaWdodCwgKHBhcnQpID0+IHtcbiAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocGFydCkpO1xuICAgIH0pO1xuICAgIGlmICghZGlkU3VjY2VlZCkge1xuICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVkID0gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpO1xuICAgIHJldHVybiBtYXRjaGVkID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIitcIjogZnVuY3Rpb24gcGx1cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmluZ1wiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm9iamVjdFwiICYmIHJpZ2h0LnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBmcm9tSlMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGxlZnQuZGF0YSksIHJpZ2h0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJhcnJheVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgcmV0dXJuIGZyb21KUyhsZWZ0LmRhdGEuY29uY2F0KHJpZ2h0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxlZnQuaXNBcnJheSgpICYmIHJpZ2h0LmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiBsZWZ0KSB7XG4gICAgICAgICAgeWllbGQgdmFsO1xuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHJpZ2h0KSB7XG4gICAgICAgICAgeWllbGQgdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIFwiLVwiOiBmdW5jdGlvbiBtaW51cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQoLXJpZ2h0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhLmRpZmZlcmVuY2UocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSAtIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCIqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAqIGIpLFxuICBcIi9cIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhIC8gYiksXG4gIFwiJVwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgJSBiKSxcbiAgXCIqKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IE1hdGgucG93KGEsIGIpKVxufTtcbmZ1bmN0aW9uIG51bWVyaWNPcGVyYXRvcihpbXBsKSB7XG4gIHJldHVybiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH07XG59XG5jbGFzcyBTY29wZSB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgc291cmNlLCB2YWx1ZSwgY29udGV4dCwgcGFyZW50KSB7XG4gICAgdGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGNyZWF0ZU5lc3RlZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcy5wYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcyk7XG4gIH1cbiAgY3JlYXRlSGlkZGVuKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIHJlc3VsdC5pc0hpZGRlbiA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuZnVuY3Rpb24gZXZhbHVhdGUobm9kZSwgc2NvcGUsIGV4ZWN1dGUgPSBldmFsdWF0ZSkge1xuICBjb25zdCBmdW5jID0gRVhFQ1VUT1JTW25vZGUudHlwZV07XG4gIHJldHVybiBmdW5jKG5vZGUsIHNjb3BlLCBleGVjdXRlKTtcbn1cbmZ1bmN0aW9uIHByb21pc2VsZXNzQXBwbHkodmFsdWUsIGNiKSB7XG4gIGlmIChcInRoZW5cIiBpbiB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50aGVuKGNiKTtcbiAgfVxuICByZXR1cm4gY2IodmFsdWUpO1xufVxuY29uc3QgRVhFQ1VUT1JTID0ge1xuICBUaGlzKF8sIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNjb3BlLnZhbHVlO1xuICB9LFxuICBFdmVyeXRoaW5nKF8sIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNjb3BlLnNvdXJjZTtcbiAgfSxcbiAgUGFyYW1ldGVyKHsgbmFtZSB9LCBzY29wZSkge1xuICAgIHJldHVybiBmcm9tSlMoc2NvcGUucGFyYW1zW25hbWVdKTtcbiAgfSxcbiAgQ29udGV4dCh7IGtleSB9LCBzY29wZSkge1xuICAgIGlmIChrZXkgPT09IFwiYmVmb3JlXCIgfHwga2V5ID09PSBcImFmdGVyXCIpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc2NvcGUuY29udGV4dFtrZXldO1xuICAgICAgcmV0dXJuIHZhbHVlIHx8IE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBjb250ZXh0IGtleTogJHtrZXl9YCk7XG4gIH0sXG4gIFBhcmVudCh7IG4gfSwgc2NvcGUpIHtcbiAgICBsZXQgY3VycmVudCA9IHNjb3BlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAoIWN1cnJlbnQucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgfSxcbiAgT3BDYWxsKHsgb3AsIGxlZnQsIHJpZ2h0IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgZnVuYyA9IG9wZXJhdG9yc1tvcF07XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0b3I6ICR7b3B9YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgaWYgKFwidGhlblwiIGluIGxlZnRWYWx1ZSB8fCBcInRoZW5cIiBpbiByaWdodFZhbHVlKSB7XG4gICAgICByZXR1cm4gKGFzeW5jICgpID0+IGZ1bmMoYXdhaXQgbGVmdFZhbHVlLCBhd2FpdCByaWdodFZhbHVlKSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgfSxcbiAgYXN5bmMgU2VsZWN0KHsgYWx0ZXJuYXRpdmVzLCBmYWxsYmFjayB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGZvciAoY29uc3QgYWx0IG9mIGFsdGVybmF0aXZlcykge1xuICAgICAgY29uc3QgYWx0Q29uZCA9IGF3YWl0IGV4ZWN1dGUoYWx0LmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgaWYgKGFsdENvbmQudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYWx0Q29uZC5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBleGVjdXRlKGFsdC52YWx1ZSwgc2NvcGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgIHJldHVybiBleGVjdXRlKGZhbGxiYWNrLCBzY29wZSk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBJblJhbmdlKHsgYmFzZSwgbGVmdCwgcmlnaHQsIGlzSW5jbHVzaXZlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIGNvbnN0IGxlZnRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgbGVmdFZhbHVlLmdldCgpKTtcbiAgICBpZiAobGVmdENtcCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IHJpZ2h0Q21wID0gcGFydGlhbENvbXBhcmUoYXdhaXQgdmFsdWUuZ2V0KCksIGF3YWl0IHJpZ2h0VmFsdWUuZ2V0KCkpO1xuICAgIGlmIChyaWdodENtcCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGlmIChpc0luY2x1c2l2ZSkge1xuICAgICAgcmV0dXJuIGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDwgMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgRmlsdGVyKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBiYXNlVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoZWxlbSk7XG4gICAgICAgIGNvbnN0IGV4cHJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBpZiAoZXhwclZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGV4cHJWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgeWllbGQgZWxlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBhc3luYyBQcm9qZWN0aW9uKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGJhc2VWYWx1ZSk7XG4gICAgcmV0dXJuIGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICB9LFxuICBGdW5jQ2FsbCh7IGZ1bmMsIGFyZ3MgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gZnVuYyhhcmdzLCBzY29wZSwgZXhlY3V0ZSk7XG4gIH0sXG4gIGFzeW5jIFBpcGVGdW5jQ2FsbCh7IGZ1bmMsIGJhc2UsIGFyZ3MgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gZnVuYyhiYXNlVmFsdWUsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgQWNjZXNzQXR0cmlidXRlKHsgYmFzZSwgbmFtZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB2YWx1ZSA9IHNjb3BlLnZhbHVlO1xuICAgIGlmIChiYXNlKSB7XG4gICAgICB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKHZhbHVlLmRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21KUyh2YWx1ZS5kYXRhW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFjY2Vzc0VsZW1lbnQoeyBiYXNlLCBpbmRleCB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XG4gICAgY29uc3QgZmluYWxJbmRleCA9IGluZGV4IDwgMCA/IGluZGV4ICsgZGF0YS5sZW5ndGggOiBpbmRleDtcbiAgICByZXR1cm4gZnJvbUpTKGRhdGFbZmluYWxJbmRleF0pO1xuICB9LFxuICBhc3luYyBTbGljZSh7IGJhc2UsIGxlZnQsIHJpZ2h0LCBpc0luY2x1c2l2ZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IGFycmF5ID0gYXdhaXQgYmFzZVZhbHVlLmdldCgpO1xuICAgIGxldCBsZWZ0SWR4ID0gbGVmdDtcbiAgICBsZXQgcmlnaHRJZHggPSByaWdodDtcbiAgICBpZiAobGVmdElkeCA8IDApIHtcbiAgICAgIGxlZnRJZHggPSBhcnJheS5sZW5ndGggKyBsZWZ0SWR4O1xuICAgIH1cbiAgICBpZiAocmlnaHRJZHggPCAwKSB7XG4gICAgICByaWdodElkeCA9IGFycmF5Lmxlbmd0aCArIHJpZ2h0SWR4O1xuICAgIH1cbiAgICBpZiAoaXNJbmNsdXNpdmUpIHtcbiAgICAgIHJpZ2h0SWR4Kys7XG4gICAgfVxuICAgIGlmIChsZWZ0SWR4IDwgMCkge1xuICAgICAgbGVmdElkeCA9IDA7XG4gICAgfVxuICAgIGlmIChyaWdodElkeCA8IDApIHtcbiAgICAgIHJpZ2h0SWR4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21KUyhhcnJheS5zbGljZShsZWZ0SWR4LCByaWdodElkeCkpO1xuICB9LFxuICBhc3luYyBEZXJlZih7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghc2NvcGUuc291cmNlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSB2YWx1ZS5kYXRhLl9yZWY7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIHNjb3BlLnNvdXJjZSkge1xuICAgICAgaWYgKGRvYy50eXBlID09PSBcIm9iamVjdFwiICYmIGlkID09PSBkb2MuZGF0YS5faWQpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIFZhbHVlKHsgdmFsdWUgfSkge1xuICAgIHJldHVybiBmcm9tSlModmFsdWUpO1xuICB9LFxuICBHcm91cCh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gIH0sXG4gIGFzeW5jIE9iamVjdCh7IGF0dHJpYnV0ZXMgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHIgb2YgYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0clR5cGUgPSBhdHRyLnR5cGU7XG4gICAgICBzd2l0Y2ggKGF0dHIudHlwZSkge1xuICAgICAgICBjYXNlIFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIjoge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgcmVzdWx0W2F0dHIubmFtZV0gPSBhd2FpdCB2YWx1ZS5nZXQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiOiB7XG4gICAgICAgICAgY29uc3QgY29uZCA9IGF3YWl0IGV4ZWN1dGUoYXR0ci5jb25kaXRpb24sIHNjb3BlKTtcbiAgICAgICAgICBpZiAoY29uZC50eXBlICE9PSBcImJvb2xlYW5cIiB8fCBjb25kLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT2JqZWN0U3BsYXRcIjoge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbm9kZSB0eXBlOiAke2F0dHJUeXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUpTKHJlc3VsdCk7XG4gIH0sXG4gIEFycmF5KHsgZWxlbWVudHMgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGVsZW1lbnQudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNTcGxhdCkge1xuICAgICAgICAgIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICB5aWVsZCB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBUdXBsZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXBsZXMgY2FuIG5vdCBiZSBldmFsdWF0ZWRcIik7XG4gIH0sXG4gIGFzeW5jIE9yKHsgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIGlmIChsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChsZWZ0VmFsdWUuZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChyaWdodFZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQW5kKHsgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIGlmIChsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChsZWZ0VmFsdWUuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgaWYgKHJpZ2h0VmFsdWUuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgTm90KHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmRhdGEgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIE5lZyh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZWxlc3NBcHBseShleGVjdXRlKGJhc2UsIHNjb3BlKSwgKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZS5kYXRhKTtcbiAgICB9KTtcbiAgfSxcbiAgUG9zKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCAodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsdWUuZGF0YSk7XG4gICAgfSk7XG4gIH0sXG4gIEFzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgRGVzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQXJyYXlDb2VyY2UoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gdmFsdWUgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBNYXAoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihlbGVtKTtcbiAgICAgICAgeWllbGQgYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGFzeW5jIEZsYXRNYXAoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihlbGVtKTtcbiAgICAgICAgY29uc3QgaW5uZXJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBpZiAoaW5uZXJWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGlubmVyIG9mIGlubmVyVmFsdWUpIHtcbiAgICAgICAgICAgIHlpZWxkIGlubmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBpbm5lclZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBldmFsdWF0ZVF1ZXJ5KHRyZWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByb290ID0gZnJvbUpTKG9wdGlvbnMucm9vdCk7XG4gIGNvbnN0IGRhdGFzZXQgPSBmcm9tSlMob3B0aW9ucy5kYXRhc2V0KTtcbiAgY29uc3QgcGFyYW1zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMucGFyYW1zKTtcbiAgY29uc3Qgc2NvcGUgPSBuZXcgU2NvcGUocGFyYW1zLCBkYXRhc2V0LCByb290LCB7XG4gICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCB8fCBuZXcgRGF0ZSgpLFxuICAgIGlkZW50aXR5OiBvcHRpb25zLmlkZW50aXR5ID09PSB2b2lkIDAgPyBcIm1lXCIgOiBvcHRpb25zLmlkZW50aXR5LFxuICAgIHNhbml0eTogb3B0aW9ucy5zYW5pdHksXG4gICAgYWZ0ZXI6IG9wdGlvbnMuYWZ0ZXIgPyBmcm9tSlMob3B0aW9ucy5hZnRlcikgOiBudWxsLFxuICAgIGJlZm9yZTogb3B0aW9ucy5iZWZvcmUgPyBmcm9tSlMob3B0aW9ucy5iZWZvcmUpIDogbnVsbFxuICB9LCBudWxsKTtcbiAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJHcm91cFwiOlxuICAgIGNhc2UgXCJWYWx1ZVwiOlxuICAgIGNhc2UgXCJQYXJhbWV0ZXJcIjpcbiAgICBjYXNlIFwiUG9zXCI6XG4gICAgY2FzZSBcIk5lZ1wiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBcIk9wQ2FsbFwiOlxuICAgICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIGNhc2UgXCIqKlwiOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jb25zdCBEVU1NWV9TQ09QRSA9IG5ldyBTY29wZSh7fSwgTlVMTF9WQUxVRSwgTlVMTF9WQUxVRSwgeyB0aW1lc3RhbXA6IG5ldyBEYXRlKDApLCBpZGVudGl0eTogXCJtZVwiLCBiZWZvcmU6IG51bGwsIGFmdGVyOiBudWxsIH0sIG51bGwpO1xuY2xhc3MgQ29uc3RhbnRFdmFsdWF0ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubmFtZSA9IFwiQ29uc3RhbnRFdmFsdWF0ZUVycm9yXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeUNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICB0cnkge1xuICAgIHJldHVybiBjb25zdGFudEV2YWx1YXRlKG5vZGUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm5hbWUgPT09IFwiQ29uc3RhbnRFdmFsdWF0ZUVycm9yXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBpZiAoIWNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgQ29uc3RhbnRFdmFsdWF0ZUVycm9yKFwiY2Fubm90IGNvbnN0YW50IGV2YWx1YXRlXCIpO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gZXZhbHVhdGUobm9kZSwgRFVNTVlfU0NPUEUsIGNvbnN0YW50RXZhbHVhdGUpO1xuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCVUc6IGNvbnN0YW50IGV2YWx1YXRlIHNob3VsZCBuZXZlciByZXR1cm4gYSBwcm9taXNlXCIpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IEVTQ0FQRV9TRVFVRU5DRSA9IHtcbiAgXCInXCI6IFwiJ1wiLFxuICAnXCInOiAnXCInLFxuICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gIFwiL1wiOiBcIi9cIixcbiAgYjogXCJcXGJcIixcbiAgZjogXCJcXGZcIixcbiAgbjogXCJcXG5cIixcbiAgcjogXCJcXHJcIixcbiAgdDogXCJcdFwiXG59O1xuZnVuY3Rpb24gZXhwYW5kSGV4KHN0cikge1xuICBjb25zdCBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59XG5jbGFzcyBHcm9xUXVlcnlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkdyb3FRdWVyeUVycm9yXCI7XG4gIH1cbn1cbmNvbnN0IEVYUFJfQlVJTERFUiA9IHtcbiAgZ3JvdXAocCkge1xuICAgIGNvbnN0IGlubmVyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiR3JvdXBcIixcbiAgICAgIGJhc2U6IGlubmVyXG4gICAgfTtcbiAgfSxcbiAgZXZlcnl0aGluZygpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIkV2ZXJ5dGhpbmdcIiB9O1xuICB9LFxuICB0aGlzKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiVGhpc1wiIH07XG4gIH0sXG4gIHBhcmVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgIG46IDFcbiAgICB9O1xuICB9LFxuICBkYmxwYXJlbnQocCkge1xuICAgIGNvbnN0IG5leHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgIG46IG5leHQubiArIDFcbiAgICB9O1xuICB9LFxuICB0cmF2ZXJzZShwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHRyYXZlcnNhbExpc3QgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0cmF2ZXJzYWxfZW5kXCIpIHtcbiAgICAgIHRyYXZlcnNhbExpc3QucHVzaChwLnByb2Nlc3MoVFJBVkVSU0VfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgbGV0IHRyYXZlcnNhbCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IHRyYXZlcnNhbExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRyYXZlcnNhbCA9IHRyYXZlcnNhbExpc3RbaV0odHJhdmVyc2FsKTtcbiAgICB9XG4gICAgaWYgKGJhc2UudHlwZSA9PT0gXCJFdmVyeXRoaW5nXCIgfHwgYmFzZS50eXBlID09PSBcIkFycmF5XCIgfHwgYmFzZS50eXBlID09PSBcIlBpcGVGdW5jQ2FsbFwiKSB7XG4gICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzZUFycmF5KCh2YWwpID0+IHZhbCwgdHJhdmVyc2FsKTtcbiAgICB9XG4gICAgaWYgKHRyYXZlcnNhbCA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogdW5leHBlY3RlZCBlbXB0eSB0cmF2ZXJzYWxcIik7XG4gICAgcmV0dXJuIHRyYXZlcnNhbC5idWlsZChiYXNlKTtcbiAgfSxcbiAgdGhpc19hdHRyKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKG5hbWUgPT09IFwibnVsbFwiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiBudWxsIH07XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcInRydWVcIikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiBmYWxzZSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9LFxuICBuZWcocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOZWdcIixcbiAgICAgIGJhc2VcbiAgICB9O1xuICB9LFxuICBwb3MocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQb3NcIixcbiAgICAgIGJhc2VcbiAgICB9O1xuICB9LFxuICBhZGQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiK1wiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgc3ViKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi1cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG11bChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBkaXYocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiL1wiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbW9kKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIiVcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHBvdyhwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgY29tcChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IG9wID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgaW5fcmFuZ2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkluUmFuZ2VcIixcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH07XG4gIH0sXG4gIHN0cihwKSB7XG4gICAgbGV0IHZhbHVlID0gXCJcIjtcbiAgICBsb29wOlxuICAgICAgd2hpbGUgKHAuaGFzTWFyaygpKSB7XG4gICAgICAgIGNvbnN0IG1hcmsgPSBwLmdldE1hcmsoKTtcbiAgICAgICAgc3dpdGNoIChtYXJrLm5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwic3RyX2VuZFwiOlxuICAgICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGNhc2UgXCJzdHJfcGF1c2VcIjpcbiAgICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInN0cl9zdGFydFwiOlxuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNpbmdsZV9lc2NhcGVcIjoge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IHAuc2xpY2UoMSk7XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YWx1ZSArPSBFU0NBUEVfU0VRVUVOQ0VbY2hhcl07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInVuaWNvZGVfaGV4XCI6XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YWx1ZSArPSBleHBhbmRIZXgocC5wcm9jZXNzU3RyaW5nRW5kKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBtYXJrOiAke21hcmsubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWUgfTtcbiAgfSxcbiAgaW50ZWdlcihwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBmbG9hdChwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBzY2kocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0KHApIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwib2JqZWN0X2VuZFwiKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gocC5wcm9jZXNzKE9CSkVDVF9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9O1xuICB9LFxuICBhcnJheShwKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJhcnJheV9lbmRcIikge1xuICAgICAgbGV0IGlzU3BsYXQgPSBmYWxzZTtcbiAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcImFycmF5X3NwbGF0XCIpIHtcbiAgICAgICAgaXNTcGxhdCA9IHRydWU7XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJBcnJheUVsZW1lbnRcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzU3BsYXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQXJyYXlcIixcbiAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgfSxcbiAgdHVwbGUocCkge1xuICAgIGNvbnN0IG1lbWJlcnMgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0dXBsZV9lbmRcIikge1xuICAgICAgbWVtYmVycy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlR1cGxlXCIsXG4gICAgICBtZW1iZXJzXG4gICAgfTtcbiAgfSxcbiAgZnVuY19jYWxsKHApIHtcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIikge1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJTZWxlY3RcIixcbiAgICAgICAgYWx0ZXJuYXRpdmVzOiBbXVxuICAgICAgfTtcbiAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGB1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpYCk7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgcmVzdWx0LmFsdGVybmF0aXZlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiU2VsZWN0QWx0ZXJuYXRpdmVcIixcbiAgICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5mYWxsYmFjaylcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgdW5leHBlY3RlZCBhcmd1bWVudCB0byBzZWxlY3QoKWApO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgcmVzdWx0LmZhbGxiYWNrID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCIpIHtcbiAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIChuYW1lID09PSBcImJlZm9yZVwiIHx8IG5hbWUgPT09IFwiYWZ0ZXJcIikpIHtcbiAgICAgIGlmIChwLnBhcnNlT3B0aW9ucy5tb2RlID09PSBcImRlbHRhXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIkNvbnRleHRcIixcbiAgICAgICAgICBrZXk6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcImJvb3N0XCIgJiYgIXAuYWxsb3dCb29zdClcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3RcIik7XG4gICAgY29uc3QgZnVuY3MgPSBuYW1lc3BhY2VzW25hbWVzcGFjZV07XG4gICAgaWYgKCFmdW5jcykge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgbmFtZXNwYWNlOiAke25hbWVzcGFjZX1gKTtcbiAgICB9XG4gICAgY29uc3QgZnVuYyA9IGZ1bmNzW25hbWVdO1xuICAgIGlmICghZnVuYykge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMuYXJpdHkgIT09IHZvaWQgMCkge1xuICAgICAgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChmdW5jLm1vZGUgIT09IHZvaWQgMCAmJiBmdW5jLm1vZGUgIT09IHAucGFyc2VPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkZ1bmNDYWxsXCIsXG4gICAgICBmdW5jLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9LFxuICBwaXBlY2FsbChwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHAuc2hpZnQoKTtcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIikge1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2UgIT09IFwiZ2xvYmFsXCIpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIG5hbWVzcGFjZTogJHtuYW1lc3BhY2V9YCk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgY29uc3Qgb2xkQWxsb3dCb29zdCA9IHAuYWxsb3dCb29zdDtcbiAgICBpZiAobmFtZSA9PT0gXCJzY29yZVwiKSB7XG4gICAgICBwLmFsbG93Qm9vc3QgPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGNvbnN0IG1hcmtOYW1lID0gcC5nZXRNYXJrKCkubmFtZTtcbiAgICAgIGlmIChtYXJrTmFtZSA9PT0gXCJmdW5jX2FyZ3NfZW5kXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gXCJvcmRlclwiKSB7XG4gICAgICAgIGlmIChtYXJrTmFtZSA9PT0gXCJhc2NcIikge1xuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBhcmdzLnB1c2goeyB0eXBlOiBcIkFzY1wiLCBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXJrTmFtZSA9PT0gXCJkZXNjXCIpIHtcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgYXJncy5wdXNoKHsgdHlwZTogXCJEZXNjXCIsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcC5hbGxvd0Jvb3N0ID0gb2xkQWxsb3dCb29zdDtcbiAgICBjb25zdCBmdW5jID0gcGlwZUZ1bmN0aW9uc1tuYW1lXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIHBpcGUgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMuYXJpdHkpIHtcbiAgICAgIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQaXBlRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBiYXNlLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9LFxuICBwYWlyKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYHVuZXhwZWN0ZWQgPT5gKTtcbiAgfSxcbiAgYW5kKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBbmRcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG9yKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPclwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbm90KHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTm90XCIsXG4gICAgICBiYXNlXG4gICAgfTtcbiAgfSxcbiAgYXNjKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFzY1wiKTtcbiAgfSxcbiAgZGVzYyhwKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBkZXNjXCIpO1xuICB9LFxuICBwYXJhbShwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGlmIChwLnBhcnNlT3B0aW9ucy5wYXJhbXMgJiYgcC5wYXJzZU9wdGlvbnMucGFyYW1zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgIHZhbHVlOiBwLnBhcnNlT3B0aW9ucy5wYXJhbXNbbmFtZV1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhcmFtZXRlclwiLFxuICAgICAgbmFtZVxuICAgIH07XG4gIH1cbn07XG5jb25zdCBPQkpFQ1RfQlVJTERFUiA9IHtcbiAgb2JqZWN0X2V4cHIocCkge1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInBhaXJcIikge1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgY29uc3QgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICBjb25zdCB2YWx1ZTIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiLFxuICAgICAgICBjb25kaXRpb24sXG4gICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcbiAgICAgIG5hbWU6IGV4dHJhY3RQcm9wZXJ0eUtleSh2YWx1ZSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9wYWlyKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgaWYgKG5hbWUudHlwZSAhPT0gXCJWYWx1ZVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXG4gICAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3Rfc3BsYXQocCkge1xuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3NwbGF0X3RoaXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlOiB7IHR5cGU6IFwiVGhpc1wiIH1cbiAgICB9O1xuICB9XG59O1xuY29uc3QgVFJBVkVSU0VfQlVJTERFUiA9IHtcbiAgc3F1YXJlX2JyYWNrZXQocCkge1xuICAgIGNvbnN0IGV4cHIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCB2YWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUoZXhwcik7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlRWxlbWVudCgoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NFbGVtZW50XCIsIGJhc2UsIGluZGV4OiB2YWx1ZS5kYXRhIH0pLCByaWdodCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lOiB2YWx1ZS5kYXRhIH0pLCByaWdodCk7XG4gICAgfVxuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlQXJyYXkoKGJhc2UpID0+ICh7XG4gICAgICB0eXBlOiBcIkZpbHRlclwiLFxuICAgICAgYmFzZSxcbiAgICAgIGV4cHJcbiAgICB9KSwgcmlnaHQpO1xuICB9LFxuICBzbGljZShwKSB7XG4gICAgY29uc3QgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKHJpZ2h0KTtcbiAgICBpZiAoIWxlZnRWYWx1ZSB8fCAhcmlnaHRWYWx1ZSB8fCBsZWZ0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInNsaWNpbmcgbXVzdCB1c2UgY29uc3RhbnQgbnVtYmVyc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIChyaHMpID0+IHRyYXZlcnNlQXJyYXkoKGJhc2UpID0+ICh7XG4gICAgICB0eXBlOiBcIlNsaWNlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbGVmdDogbGVmdFZhbHVlLmRhdGEsXG4gICAgICByaWdodDogcmlnaHRWYWx1ZS5kYXRhLFxuICAgICAgaXNJbmNsdXNpdmVcbiAgICB9KSwgcmhzKTtcbiAgfSxcbiAgcHJvamVjdGlvbihwKSB7XG4gICAgY29uc3Qgb2JqID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQcm9qZWN0aW9uKChiYXNlKSA9PiAoeyB0eXBlOiBcIlByb2plY3Rpb25cIiwgYmFzZSwgZXhwcjogb2JqIH0pLCByaWdodCk7XG4gIH0sXG4gIGF0dHJfYWNjZXNzKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbigoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZSB9KSwgcmlnaHQpO1xuICB9LFxuICBkZXJlZihwKSB7XG4gICAgbGV0IGF0dHIgPSBudWxsO1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcImRlcmVmX2F0dHJcIikge1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgYXR0ciA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCB3cmFwID0gKGJhc2UpID0+IGF0dHIgPyB7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWU6IGF0dHIgfSA6IGJhc2U7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbigoYmFzZSkgPT4gd3JhcCh7XG4gICAgICB0eXBlOiBcIkRlcmVmXCIsXG4gICAgICBiYXNlXG4gICAgfSksIHJpZ2h0KTtcbiAgfSxcbiAgYXJyYXlfcG9zdGZpeChwKSB7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VBcnJheSgoYmFzZSkgPT4gKHsgdHlwZTogXCJBcnJheUNvZXJjZVwiLCBiYXNlIH0pLCByaWdodCk7XG4gIH1cbn07XG5mdW5jdGlvbiBleHRyYWN0UHJvcGVydHlLZXkobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIkFjY2Vzc0F0dHJpYnV0ZVwiICYmICFub2RlLmJhc2UpIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiRGVyZWZcIiB8fCBub2RlLnR5cGUgPT09IFwiTWFwXCIgfHwgbm9kZS50eXBlID09PSBcIlByb2plY3Rpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiU2xpY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiRmlsdGVyXCIgfHwgbm9kZS50eXBlID09PSBcIkFjY2Vzc0VsZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiQXJyYXlDb2VyY2VcIikge1xuICAgIHJldHVybiBleHRyYWN0UHJvcGVydHlLZXkobm9kZS5iYXNlKTtcbiAgfVxuICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYENhbm5vdCBkZXRlcm1pbmUgcHJvcGVydHkga2V5IGZvciB0eXBlOiAke25vZGUudHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXJpdHkobmFtZSwgYXJpdHksIGNvdW50Mikge1xuICBpZiAodHlwZW9mIGFyaXR5ID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGNvdW50MiAhPT0gYXJpdHkpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJHtuYW1lfSgpLiBFeHBlY3RlZCAke2FyaXR5fSwgZ290ICR7Y291bnQyfS5gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJpdHkpIHtcbiAgICBpZiAoIWFyaXR5KGNvdW50MikpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJHtuYW1lfSgpLmApO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR3JvcVN5bnRheEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbikge1xuICAgIHN1cGVyKGBTeW50YXggZXJyb3IgaW4gR1JPUSBxdWVyeSBhdCBwb3NpdGlvbiAke3Bvc2l0aW9ufWApO1xuICAgIHRoaXMubmFtZSA9IFwiR3JvcVN5bnRheEVycm9yXCI7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHBhcnNlJDEoaW5wdXQpO1xuICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgIHRocm93IG5ldyBHcm9xU3ludGF4RXJyb3IocmVzdWx0LnBvc2l0aW9uKTtcbiAgfVxuICBjb25zdCBwcm9jZXNzb3IgPSBuZXcgTWFya1Byb2Nlc3NvcihpbnB1dCwgcmVzdWx0Lm1hcmtzLCBvcHRpb25zKTtcbiAgcmV0dXJuIHByb2Nlc3Nvci5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG59XG5leHBvcnQgeyBldmFsdWF0ZVF1ZXJ5IGFzIGV2YWx1YXRlLCBwYXJzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvcS1qcy5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../sanity-nextmedium/node_modules/@sanity/groq-store/node_modules/groq-js/dist/groq-js.esm.js\n");

/***/ }),

/***/ "../sanity-nextmedium/node_modules/fast-deep-equal/index.js":
/*!******************************************************************!*\
  !*** ../sanity-nextmedium/node_modules/fast-deep-equal/index.js ***!
  \******************************************************************/
/***/ (function(module) {

"use strict";
eval("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcz8zMTRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../sanity-nextmedium/node_modules/fast-deep-equal/index.js\n");

/***/ }),

/***/ "../sanity-nextmedium/node_modules/mendoza/lib/esm/incremental-patcher.js":
/*!********************************************************************************!*\
  !*** ../sanity-nextmedium/node_modules/mendoza/lib/esm/incremental-patcher.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"wrap\": function() { return /* binding */ wrap; },\n/* harmony export */   \"unwrap\": function() { return /* binding */ unwrap; },\n/* harmony export */   \"getType\": function() { return /* binding */ getType; },\n/* harmony export */   \"rebaseValue\": function() { return /* binding */ rebaseValue; },\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"../sanity-nextmedium/node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"../sanity-nextmedium/node_modules/mendoza/lib/esm/utf8.js\");\n\n\nvar Model = /** @class */ (function () {\n    function Model(meta) {\n        this.meta = meta;\n    }\n    Model.prototype.wrap = function (data) {\n        return this.wrapWithMeta(data, this.meta, this.meta);\n    };\n    Model.prototype.wrapWithMeta = function (data, startMeta, endMeta) {\n        if (endMeta === void 0) { endMeta = this.meta; }\n        return { data: data, startMeta: startMeta, endMeta: endMeta };\n    };\n    Model.prototype.asObject = function (value) {\n        if (!value.content) {\n            var fields = {};\n            for (var _i = 0, _a = Object.entries(value.data); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                fields[key] = this.wrapWithMeta(val, value.startMeta);\n            }\n            value.content = { type: 'object', fields: fields };\n        }\n        return value.content;\n    };\n    Model.prototype.asArray = function (value) {\n        var _this = this;\n        if (!value.content) {\n            var elements = value.data.map(function (item) { return _this.wrapWithMeta(item, value.startMeta); });\n            var metas = elements.map(function () { return _this.meta; });\n            value.content = { type: 'array', elements: elements, metas: metas };\n        }\n        return value.content;\n    };\n    Model.prototype.asString = function (value) {\n        if (!value.content) {\n            var str = value.data;\n            var part = {\n                value: str,\n                utf8size: (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(str),\n                uses: [],\n                startMeta: value.startMeta,\n                endMeta: value.endMeta\n            };\n            value.content = this.stringFromParts([part]);\n        }\n        return value.content;\n    };\n    Model.prototype.stringFromParts = function (parts) {\n        var str = {\n            type: 'string',\n            parts: parts\n        };\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            part.uses.push(str);\n        }\n        return str;\n    };\n    Model.prototype.objectGetKeys = function (value) {\n        if (value.content) {\n            return Object.keys(value.content.fields);\n        }\n        else {\n            return Object.keys(value.data);\n        }\n    };\n    Model.prototype.objectGetField = function (value, key) {\n        var obj = this.asObject(value);\n        return obj.fields[key];\n    };\n    Model.prototype.arrayGetElement = function (value, idx) {\n        var arr = this.asArray(value);\n        return arr.elements[idx];\n    };\n    Model.prototype.finalize = function (content) {\n        this.updateEndMeta(content);\n        return { content: content, startMeta: this.meta, endMeta: this.meta };\n    };\n    Model.prototype.markChanged = function (value) {\n        return this.wrap(unwrap(value));\n    };\n    Model.prototype.updateEndMeta = function (content) {\n        if (content.type == 'string') {\n            for (var _i = 0, _a = content.parts; _i < _a.length; _i++) {\n                var part = _a[_i];\n                part.endMeta = this.meta;\n            }\n        }\n        else {\n            if (content.type === 'array') {\n                for (var _b = 0, _c = content.elements; _b < _c.length; _b++) {\n                    var val = _c[_b];\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            }\n            else {\n                for (var _d = 0, _e = Object.values(content.fields); _d < _e.length; _d++) {\n                    var val = _e[_d];\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            }\n        }\n    };\n    Model.prototype.copyString = function (value) {\n        if (value) {\n            var other = this.asString(value);\n            return this.stringFromParts(other.parts.slice());\n        }\n        else {\n            return {\n                type: 'string',\n                parts: []\n            };\n        }\n    };\n    Model.prototype.copyObject = function (value) {\n        var obj = {\n            type: 'object',\n            fields: {}\n        };\n        if (value) {\n            var other = this.asObject(value);\n            Object.assign(obj.fields, other.fields);\n        }\n        return obj;\n    };\n    Model.prototype.copyArray = function (value) {\n        var arr = value ? this.asArray(value) : null;\n        var elements = arr ? arr.elements : [];\n        var metas = arr ? arr.metas : [];\n        return {\n            type: 'array',\n            elements: elements,\n            metas: metas\n        };\n    };\n    Model.prototype.objectSetField = function (target, key, value) {\n        target.fields[key] = value;\n    };\n    Model.prototype.objectDeleteField = function (target, key) {\n        delete target.fields[key];\n    };\n    Model.prototype.arrayAppendValue = function (target, value) {\n        target.elements.push(value);\n        target.metas.push(this.meta);\n    };\n    Model.prototype.arrayAppendSlice = function (target, source, left, right) {\n        var _a, _b;\n        var arr = this.asArray(source);\n        var samePosition = arr.elements.length === left;\n        (_a = target.elements).push.apply(_a, arr.elements.slice(left, right));\n        if (samePosition) {\n            (_b = target.metas).push.apply(_b, arr.metas.slice(left, right));\n        }\n        else {\n            for (var i = left; i < right; i++) {\n                target.metas.push(this.meta);\n            }\n        }\n    };\n    Model.prototype.stringAppendValue = function (target, value) {\n        var str = this.asString(value);\n        for (var _i = 0, _a = str.parts; _i < _a.length; _i++) {\n            var part = _a[_i];\n            this.stringAppendPart(target, part);\n        }\n    };\n    Model.prototype.stringAppendPart = function (target, part) {\n        target.parts.push(part);\n        part.uses.push(target);\n    };\n    Model.prototype.resolveStringPart = function (str, from, len) {\n        if (len === 0)\n            return from;\n        for (var i = from; i < str.parts.length; i++) {\n            var part = str.parts[i];\n            if (len === part.utf8size) {\n                // Matches perfect!\n                return i + 1;\n            }\n            if (len < part.utf8size) {\n                // It's a part of this chunk. We now need to split it up.\n                this.splitString(part, len);\n                return i + 1;\n            }\n            len -= part.utf8size;\n        }\n        throw new Error('splitting string out of bounds');\n    };\n    Model.prototype.splitString = function (part, idx) {\n        var leftValue;\n        var rightValue;\n        var leftSize = idx;\n        var rightSize = part.utf8size - leftSize;\n        // idx is here in UTF-8 index, not codepoint index.\n        // This means we might to adjust for multi-byte characters.\n        if (part.utf8size !== part.value.length) {\n            var byteCount = 0;\n            for (idx = 0; byteCount < leftSize; idx++) {\n                var code = part.value.codePointAt(idx);\n                var size = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8charSize)(code);\n                if (size === 4)\n                    idx++; // Surrogate pair.\n                byteCount += size;\n            }\n        }\n        leftValue = part.value.slice(0, idx);\n        rightValue = part.value.slice(idx);\n        var newPart = {\n            value: rightValue,\n            utf8size: rightSize,\n            uses: part.uses.slice(),\n            startMeta: part.startMeta,\n            endMeta: part.endMeta\n        };\n        part.value = leftValue;\n        part.utf8size = leftSize;\n        for (var _i = 0, _a = part.uses; _i < _a.length; _i++) {\n            var use = _a[_i];\n            // Insert the new part.\n            var idx_1 = use.parts.indexOf(part);\n            if (idx_1 === -1)\n                throw new Error('bug: mismatch between string parts and use.');\n            use.parts.splice(idx_1 + 1, 0, newPart);\n        }\n    };\n    Model.prototype.stringAppendSlice = function (target, source, left, right) {\n        var str = this.asString(source);\n        var firstPart = this.resolveStringPart(str, 0, left);\n        var lastPart = this.resolveStringPart(str, firstPart, right - left);\n        for (var i = firstPart; i < lastPart; i++) {\n            var part = str.parts[i];\n            this.stringAppendPart(target, part);\n        }\n    };\n    return Model;\n}());\n// Turns a native JavaScript object into a Value with a given origin.\nfunction wrap(data, meta) {\n    return { data: data, startMeta: meta, endMeta: meta };\n}\n// Converts a Value into a native JavaScript type.\nfunction unwrap(value) {\n    if (typeof value.data !== 'undefined')\n        return value.data;\n    var result;\n    var content = value.content;\n    switch (content.type) {\n        case 'string':\n            result = content.parts.map(function (part) { return part.value; }).join('');\n            break;\n        case 'array':\n            result = content.elements.map(function (val) { return unwrap(val); });\n            break;\n        case 'object': {\n            result = {};\n            for (var _i = 0, _a = Object.entries(content.fields); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                result[key] = unwrap(val);\n            }\n        }\n    }\n    value.data = result;\n    return result;\n}\n// Returns the type of a Value.\nfunction getType(value) {\n    if (value.content)\n        return value.content.type;\n    if (Array.isArray(value.data))\n        return 'array';\n    if (value.data === null)\n        return 'null';\n    return typeof value.data;\n}\n// Updates the `right` value such that it reuses as much as possible from the `left` value.\nfunction rebaseValue(left, right) {\n    var leftType = getType(left);\n    var rightType = getType(right);\n    if (leftType !== rightType)\n        return right;\n    var leftModel = new Model(left.endMeta);\n    var rightModel = new Model(right.endMeta);\n    switch (leftType) {\n        case 'object': {\n            var leftObj = leftModel.asObject(left);\n            var rightObj = rightModel.asObject(right);\n            // Number of fields which are identical in left and right.\n            var identicalFieldCount = 0;\n            var leftFieldCount = Object.keys(leftObj.fields).length;\n            var rightFieldCount = Object.keys(rightObj.fields).length;\n            for (var _i = 0, _a = Object.entries(rightObj.fields); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], rightVal = _b[1];\n                var leftVal = leftObj.fields[key];\n                if (leftVal) {\n                    rightObj.fields[key] = rebaseValue(leftVal, rightVal);\n                    if (rightObj.fields[key] === leftVal) {\n                        identicalFieldCount++;\n                    }\n                }\n            }\n            var isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;\n            return isIdentical ? left : right;\n        }\n        case 'array': {\n            var leftArr = leftModel.asArray(left);\n            var rightArr = rightModel.asArray(right);\n            if (leftArr.elements.length !== rightArr.elements.length) {\n                break;\n            }\n            var numRebased = 0;\n            for (var i = 0; i < rightArr.elements.length; i++) {\n                rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);\n                if (rightArr.elements[i] !== leftArr.elements[i]) {\n                    numRebased++;\n                }\n            }\n            return numRebased === 0 ? left : right;\n        }\n        case 'null':\n        case 'boolean':\n        case 'number': {\n            if (unwrap(left) === unwrap(right))\n                return left;\n            break;\n        }\n        case 'string': {\n            var leftRaw = unwrap(left);\n            var rightRaw = unwrap(right);\n            if (leftRaw === rightRaw)\n                return left;\n            var result = rightModel.copyString(null);\n            var prefix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonPrefix)(leftRaw, rightRaw);\n            var suffix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonSuffix)(leftRaw, rightRaw, prefix);\n            var rightLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(rightRaw);\n            var leftLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(leftRaw);\n            if (0 < prefix) {\n                rightModel.stringAppendSlice(result, left, 0, prefix);\n            }\n            if (prefix < rightLen - suffix) {\n                rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);\n            }\n            if (leftLen - suffix < leftLen) {\n                rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\n            }\n            var value = rightModel.finalize(result);\n            if (unwrap(value) !== rightRaw)\n                throw new Error('incorrect string rebase');\n            return value;\n        }\n    }\n    return right;\n}\nfunction applyPatch(left, patch, startMeta) {\n    var model = new Model(startMeta);\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(model, left, patch);\n    return patcher.process();\n}\n//# sourceMappingURL=incremental-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9pbmNyZW1lbnRhbC1wYXRjaGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkM7QUFDcUM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsbURBQW1EO0FBQy9HLG1EQUFtRCxvQkFBb0I7QUFDdkUsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscURBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBLDJCQUEyQixtREFBWTtBQUN2QztBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUCxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9CQUFvQjtBQUM3RTtBQUNBO0FBQ0EsMkRBQTJELHFCQUFxQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBWTtBQUNyQyx5QkFBeUIsbURBQVk7QUFDckMsMkJBQTJCLHFEQUFjO0FBQ3pDLDBCQUEwQixxREFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHNCQUFzQixzREFBTztBQUM3QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3Nhbml0eS1uZXh0bWVkaXVtL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vaW5jcmVtZW50YWwtcGF0Y2hlci5qcz8xZTk1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhdGNoZXIgfSBmcm9tICcuL2ludGVybmFsLXBhdGNoZXInO1xuaW1wb3J0IHsgdXRmOGNoYXJTaXplLCB1dGY4c3RyaW5nU2l6ZSwgY29tbW9uUHJlZml4LCBjb21tb25TdWZmaXggfSBmcm9tICcuL3V0ZjgnO1xudmFyIE1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGVsKG1ldGEpIHtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICB9XG4gICAgTW9kZWwucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwV2l0aE1ldGEoZGF0YSwgdGhpcy5tZXRhLCB0aGlzLm1ldGEpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLndyYXBXaXRoTWV0YSA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydE1ldGEsIGVuZE1ldGEpIHtcbiAgICAgICAgaWYgKGVuZE1ldGEgPT09IHZvaWQgMCkgeyBlbmRNZXRhID0gdGhpcy5tZXRhOyB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIHN0YXJ0TWV0YTogc3RhcnRNZXRhLCBlbmRNZXRhOiBlbmRNZXRhIH07XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNPYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgZmllbGRzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModmFsdWUuZGF0YSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgZmllbGRzW2tleV0gPSB0aGlzLndyYXBXaXRoTWV0YSh2YWwsIHZhbHVlLnN0YXJ0TWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZS5jb250ZW50ID0geyB0eXBlOiAnb2JqZWN0JywgZmllbGRzOiBmaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdmFsdWUuZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIF90aGlzLndyYXBXaXRoTWV0YShpdGVtLCB2YWx1ZS5zdGFydE1ldGEpOyB9KTtcbiAgICAgICAgICAgIHZhciBtZXRhcyA9IGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXRhOyB9KTtcbiAgICAgICAgICAgIHZhbHVlLmNvbnRlbnQgPSB7IHR5cGU6ICdhcnJheScsIGVsZW1lbnRzOiBlbGVtZW50cywgbWV0YXM6IG1ldGFzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgICAgICAgICAgdXRmOHNpemU6IHV0ZjhzdHJpbmdTaXplKHN0ciksXG4gICAgICAgICAgICAgICAgdXNlczogW10sXG4gICAgICAgICAgICAgICAgc3RhcnRNZXRhOiB2YWx1ZS5zdGFydE1ldGEsXG4gICAgICAgICAgICAgICAgZW5kTWV0YTogdmFsdWUuZW5kTWV0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlLmNvbnRlbnQgPSB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhbcGFydF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnN0cmluZ0Zyb21QYXJ0cyA9IGZ1bmN0aW9uIChwYXJ0cykge1xuICAgICAgICB2YXIgc3RyID0ge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBwYXJ0czogcGFydHNcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYXJ0c18xID0gcGFydHM7IF9pIDwgcGFydHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNfMVtfaV07XG4gICAgICAgICAgICBwYXJ0LnVzZXMucHVzaChzdHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUub2JqZWN0R2V0S2V5cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlLmNvbnRlbnQuZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdEdldEZpZWxkID0gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuYXNPYmplY3QodmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqLmZpZWxkc1trZXldO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5R2V0RWxlbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLmFzQXJyYXkodmFsdWUpO1xuICAgICAgICByZXR1cm4gYXJyLmVsZW1lbnRzW2lkeF07XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEoY29udGVudCk7XG4gICAgICAgIHJldHVybiB7IGNvbnRlbnQ6IGNvbnRlbnQsIHN0YXJ0TWV0YTogdGhpcy5tZXRhLCBlbmRNZXRhOiB0aGlzLm1ldGEgfTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5tYXJrQ2hhbmdlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwKHVud3JhcCh2YWx1ZSkpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnVwZGF0ZUVuZE1ldGEgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICBpZiAoY29udGVudC50eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29udGVudC5wYXJ0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBwYXJ0LmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGNvbnRlbnQuZWxlbWVudHM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwuY29udGVudCAmJiB2YWwuZW5kTWV0YSAhPT0gdGhpcy5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSBPYmplY3QudmFsdWVzKGNvbnRlbnQuZmllbGRzKTsgX2QgPCBfZS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9lW19kXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5jb250ZW50ICYmIHZhbC5lbmRNZXRhICE9PSB0aGlzLm1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRW5kTWV0YSh2YWwuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsLmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuY29weVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IHRoaXMuYXNTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nRnJvbVBhcnRzKG90aGVyLnBhcnRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBwYXJ0czogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5jb3B5T2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGZpZWxkczoge31cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob2JqLmZpZWxkcywgb3RoZXIuZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmNvcHlBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgYXJyID0gdmFsdWUgPyB0aGlzLmFzQXJyYXkodmFsdWUpIDogbnVsbDtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gYXJyID8gYXJyLmVsZW1lbnRzIDogW107XG4gICAgICAgIHZhciBtZXRhcyA9IGFyciA/IGFyci5tZXRhcyA6IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgIG1ldGFzOiBtZXRhc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdFNldEZpZWxkID0gZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQuZmllbGRzW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3REZWxldGVGaWVsZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0LmZpZWxkc1trZXldO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5QXBwZW5kVmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQuZWxlbWVudHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRhcmdldC5tZXRhcy5wdXNoKHRoaXMubWV0YSk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXJyYXlBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuYXNBcnJheShzb3VyY2UpO1xuICAgICAgICB2YXIgc2FtZVBvc2l0aW9uID0gYXJyLmVsZW1lbnRzLmxlbmd0aCA9PT0gbGVmdDtcbiAgICAgICAgKF9hID0gdGFyZ2V0LmVsZW1lbnRzKS5wdXNoLmFwcGx5KF9hLCBhcnIuZWxlbWVudHMuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgaWYgKHNhbWVQb3NpdGlvbikge1xuICAgICAgICAgICAgKF9iID0gdGFyZ2V0Lm1ldGFzKS5wdXNoLmFwcGx5KF9iLCBhcnIubWV0YXMuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZWZ0OyBpIDwgcmlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5tZXRhcy5wdXNoKHRoaXMubWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRWYWx1ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHN0ci5wYXJ0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gX2FbX2ldO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRQYXJ0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFydCkge1xuICAgICAgICB0YXJnZXQucGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgcGFydC51c2VzLnB1c2godGFyZ2V0KTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5yZXNvbHZlU3RyaW5nUGFydCA9IGZ1bmN0aW9uIChzdHIsIGZyb20sIGxlbikge1xuICAgICAgICBpZiAobGVuID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgc3RyLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHN0ci5wYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChsZW4gPT09IHBhcnQudXRmOHNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaGVzIHBlcmZlY3QhXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbiA8IHBhcnQudXRmOHNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgcGFydCBvZiB0aGlzIGNodW5rLiBXZSBub3cgbmVlZCB0byBzcGxpdCBpdCB1cC5cbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0U3RyaW5nKHBhcnQsIGxlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuIC09IHBhcnQudXRmOHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdHRpbmcgc3RyaW5nIG91dCBvZiBib3VuZHMnKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zcGxpdFN0cmluZyA9IGZ1bmN0aW9uIChwYXJ0LCBpZHgpIHtcbiAgICAgICAgdmFyIGxlZnRWYWx1ZTtcbiAgICAgICAgdmFyIHJpZ2h0VmFsdWU7XG4gICAgICAgIHZhciBsZWZ0U2l6ZSA9IGlkeDtcbiAgICAgICAgdmFyIHJpZ2h0U2l6ZSA9IHBhcnQudXRmOHNpemUgLSBsZWZ0U2l6ZTtcbiAgICAgICAgLy8gaWR4IGlzIGhlcmUgaW4gVVRGLTggaW5kZXgsIG5vdCBjb2RlcG9pbnQgaW5kZXguXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgd2UgbWlnaHQgdG8gYWRqdXN0IGZvciBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChwYXJ0LnV0ZjhzaXplICE9PSBwYXJ0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJ5dGVDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGlkeCA9IDA7IGJ5dGVDb3VudCA8IGxlZnRTaXplOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gcGFydC52YWx1ZS5jb2RlUG9pbnRBdChpZHgpO1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplID09PSA0KVxuICAgICAgICAgICAgICAgICAgICBpZHgrKzsgLy8gU3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50ICs9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGVmdFZhbHVlID0gcGFydC52YWx1ZS5zbGljZSgwLCBpZHgpO1xuICAgICAgICByaWdodFZhbHVlID0gcGFydC52YWx1ZS5zbGljZShpZHgpO1xuICAgICAgICB2YXIgbmV3UGFydCA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByaWdodFZhbHVlLFxuICAgICAgICAgICAgdXRmOHNpemU6IHJpZ2h0U2l6ZSxcbiAgICAgICAgICAgIHVzZXM6IHBhcnQudXNlcy5zbGljZSgpLFxuICAgICAgICAgICAgc3RhcnRNZXRhOiBwYXJ0LnN0YXJ0TWV0YSxcbiAgICAgICAgICAgIGVuZE1ldGE6IHBhcnQuZW5kTWV0YVxuICAgICAgICB9O1xuICAgICAgICBwYXJ0LnZhbHVlID0gbGVmdFZhbHVlO1xuICAgICAgICBwYXJ0LnV0ZjhzaXplID0gbGVmdFNpemU7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBwYXJ0LnVzZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdXNlID0gX2FbX2ldO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBuZXcgcGFydC5cbiAgICAgICAgICAgIHZhciBpZHhfMSA9IHVzZS5wYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICAgICAgaWYgKGlkeF8xID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2J1ZzogbWlzbWF0Y2ggYmV0d2VlbiBzdHJpbmcgcGFydHMgYW5kIHVzZS4nKTtcbiAgICAgICAgICAgIHVzZS5wYXJ0cy5zcGxpY2UoaWR4XzEgKyAxLCAwLCBuZXdQYXJ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnN0cmluZ0FwcGVuZFNsaWNlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5hc1N0cmluZyhzb3VyY2UpO1xuICAgICAgICB2YXIgZmlyc3RQYXJ0ID0gdGhpcy5yZXNvbHZlU3RyaW5nUGFydChzdHIsIDAsIGxlZnQpO1xuICAgICAgICB2YXIgbGFzdFBhcnQgPSB0aGlzLnJlc29sdmVTdHJpbmdQYXJ0KHN0ciwgZmlyc3RQYXJ0LCByaWdodCAtIGxlZnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RQYXJ0OyBpIDwgbGFzdFBhcnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBzdHIucGFydHNbaV07XG4gICAgICAgICAgICB0aGlzLnN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1vZGVsO1xufSgpKTtcbi8vIFR1cm5zIGEgbmF0aXZlIEphdmFTY3JpcHQgb2JqZWN0IGludG8gYSBWYWx1ZSB3aXRoIGEgZ2l2ZW4gb3JpZ2luLlxuZXhwb3J0IGZ1bmN0aW9uIHdyYXAoZGF0YSwgbWV0YSkge1xuICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIHN0YXJ0TWV0YTogbWV0YSwgZW5kTWV0YTogbWV0YSB9O1xufVxuLy8gQ29udmVydHMgYSBWYWx1ZSBpbnRvIGEgbmF0aXZlIEphdmFTY3JpcHQgdHlwZS5cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlLmRhdGEgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gdmFsdWUuZGF0YTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBjb250ZW50ID0gdmFsdWUuY29udGVudDtcbiAgICBzd2l0Y2ggKGNvbnRlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmVzdWx0ID0gY29udGVudC5wYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIHBhcnQudmFsdWU7IH0pLmpvaW4oJycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnRlbnQuZWxlbWVudHMubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHVud3JhcCh2YWwpOyB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhjb250ZW50LmZpZWxkcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB1bndyYXAodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZS5kYXRhID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBSZXR1cm5zIHRoZSB0eXBlIG9mIGEgVmFsdWUuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb250ZW50KVxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudC50eXBlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKVxuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICBpZiAodmFsdWUuZGF0YSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLmRhdGE7XG59XG4vLyBVcGRhdGVzIHRoZSBgcmlnaHRgIHZhbHVlIHN1Y2ggdGhhdCBpdCByZXVzZXMgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBgbGVmdGAgdmFsdWUuXG5leHBvcnQgZnVuY3Rpb24gcmViYXNlVmFsdWUobGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgbGVmdFR5cGUgPSBnZXRUeXBlKGxlZnQpO1xuICAgIHZhciByaWdodFR5cGUgPSBnZXRUeXBlKHJpZ2h0KTtcbiAgICBpZiAobGVmdFR5cGUgIT09IHJpZ2h0VHlwZSlcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIHZhciBsZWZ0TW9kZWwgPSBuZXcgTW9kZWwobGVmdC5lbmRNZXRhKTtcbiAgICB2YXIgcmlnaHRNb2RlbCA9IG5ldyBNb2RlbChyaWdodC5lbmRNZXRhKTtcbiAgICBzd2l0Y2ggKGxlZnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgIHZhciBsZWZ0T2JqID0gbGVmdE1vZGVsLmFzT2JqZWN0KGxlZnQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0T2JqID0gcmlnaHRNb2RlbC5hc09iamVjdChyaWdodCk7XG4gICAgICAgICAgICAvLyBOdW1iZXIgb2YgZmllbGRzIHdoaWNoIGFyZSBpZGVudGljYWwgaW4gbGVmdCBhbmQgcmlnaHQuXG4gICAgICAgICAgICB2YXIgaWRlbnRpY2FsRmllbGRDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVmdEZpZWxkQ291bnQgPSBPYmplY3Qua2V5cyhsZWZ0T2JqLmZpZWxkcykubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHJpZ2h0RmllbGRDb3VudCA9IE9iamVjdC5rZXlzKHJpZ2h0T2JqLmZpZWxkcykubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHJpZ2h0T2JqLmZpZWxkcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgcmlnaHRWYWwgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFZhbCA9IGxlZnRPYmouZmllbGRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRPYmouZmllbGRzW2tleV0gPSByZWJhc2VWYWx1ZShsZWZ0VmFsLCByaWdodFZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodE9iai5maWVsZHNba2V5XSA9PT0gbGVmdFZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpY2FsRmllbGRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlzSWRlbnRpY2FsID0gbGVmdEZpZWxkQ291bnQgPT09IHJpZ2h0RmllbGRDb3VudCAmJiBsZWZ0RmllbGRDb3VudCA9PT0gaWRlbnRpY2FsRmllbGRDb3VudDtcbiAgICAgICAgICAgIHJldHVybiBpc0lkZW50aWNhbCA/IGxlZnQgOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdhcnJheSc6IHtcbiAgICAgICAgICAgIHZhciBsZWZ0QXJyID0gbGVmdE1vZGVsLmFzQXJyYXkobGVmdCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRBcnIgPSByaWdodE1vZGVsLmFzQXJyYXkocmlnaHQpO1xuICAgICAgICAgICAgaWYgKGxlZnRBcnIuZWxlbWVudHMubGVuZ3RoICE9PSByaWdodEFyci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudW1SZWJhc2VkID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmlnaHRBcnIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByaWdodEFyci5lbGVtZW50c1tpXSA9IHJlYmFzZVZhbHVlKGxlZnRBcnIuZWxlbWVudHNbaV0sIHJpZ2h0QXJyLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRBcnIuZWxlbWVudHNbaV0gIT09IGxlZnRBcnIuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUmViYXNlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1SZWJhc2VkID09PSAwID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgaWYgKHVud3JhcChsZWZ0KSA9PT0gdW53cmFwKHJpZ2h0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgICAgIHZhciBsZWZ0UmF3ID0gdW53cmFwKGxlZnQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0UmF3ID0gdW53cmFwKHJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChsZWZ0UmF3ID09PSByaWdodFJhdylcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByaWdodE1vZGVsLmNvcHlTdHJpbmcobnVsbCk7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29tbW9uUHJlZml4KGxlZnRSYXcsIHJpZ2h0UmF3KTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBjb21tb25TdWZmaXgobGVmdFJhdywgcmlnaHRSYXcsIHByZWZpeCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRMZW4gPSB1dGY4c3RyaW5nU2l6ZShyaWdodFJhdyk7XG4gICAgICAgICAgICB2YXIgbGVmdExlbiA9IHV0ZjhzdHJpbmdTaXplKGxlZnRSYXcpO1xuICAgICAgICAgICAgaWYgKDAgPCBwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgMCwgcHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVmaXggPCByaWdodExlbiAtIHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHJpZ2h0TW9kZWwuc3RyaW5nQXBwZW5kU2xpY2UocmVzdWx0LCByaWdodCwgcHJlZml4LCByaWdodExlbiAtIHN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdExlbiAtIHN1ZmZpeCA8IGxlZnRMZW4pIHtcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgbGVmdExlbiAtIHN1ZmZpeCwgbGVmdExlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByaWdodE1vZGVsLmZpbmFsaXplKHJlc3VsdCk7XG4gICAgICAgICAgICBpZiAodW53cmFwKHZhbHVlKSAhPT0gcmlnaHRSYXcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvcnJlY3Qgc3RyaW5nIHJlYmFzZScpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByaWdodDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGxlZnQsIHBhdGNoLCBzdGFydE1ldGEpIHtcbiAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoc3RhcnRNZXRhKTtcbiAgICB2YXIgcGF0Y2hlciA9IG5ldyBQYXRjaGVyKG1vZGVsLCBsZWZ0LCBwYXRjaCk7XG4gICAgcmV0dXJuIHBhdGNoZXIucHJvY2VzcygpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5jcmVtZW50YWwtcGF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../sanity-nextmedium/node_modules/mendoza/lib/esm/incremental-patcher.js\n");

/***/ }),

/***/ "../sanity-nextmedium/node_modules/mendoza/lib/esm/index.js":
/*!******************************************************************!*\
  !*** ../sanity-nextmedium/node_modules/mendoza/lib/esm/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"incremental\": function() { return /* reexport module object */ _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   \"applyPatch\": function() { return /* reexport safe */ _simple_patcher__WEBPACK_IMPORTED_MODULE_1__.applyPatch; }\n/* harmony export */ });\n/* harmony import */ var _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./incremental-patcher */ \"../sanity-nextmedium/node_modules/mendoza/lib/esm/incremental-patcher.js\");\n/* harmony import */ var _simple_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-patcher */ \"../sanity-nextmedium/node_modules/mendoza/lib/esm/simple-patcher.js\");\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVEO0FBQ2Y7QUFDTTtBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9pbmRleC5qcz8zNDViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGluY3JlbWVudGFsXzEgZnJvbSAnLi9pbmNyZW1lbnRhbC1wYXRjaGVyJztcbmV4cG9ydCB7IGluY3JlbWVudGFsXzEgYXMgaW5jcmVtZW50YWwgfTtcbmV4cG9ydCB7IGFwcGx5UGF0Y2ggfSBmcm9tICcuL3NpbXBsZS1wYXRjaGVyJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../sanity-nextmedium/node_modules/mendoza/lib/esm/index.js\n");

/***/ }),

/***/ "../sanity-nextmedium/node_modules/mendoza/lib/esm/internal-patcher.js":
/*!*****************************************************************************!*\
  !*** ../sanity-nextmedium/node_modules/mendoza/lib/esm/internal-patcher.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Patcher\": function() { return /* binding */ Patcher; }\n/* harmony export */ });\nvar OPS = [\n    'Value',\n    'Copy',\n    'Blank',\n    'ReturnIntoArray',\n    'ReturnIntoObject',\n    'ReturnIntoObjectSameKey',\n    'PushField',\n    'PushElement',\n    'PushParent',\n    'Pop',\n    'PushFieldCopy',\n    'PushFieldBlank',\n    'PushElementCopy',\n    'PushElementBlank',\n    'ReturnIntoObjectPop',\n    'ReturnIntoObjectSameKeyPop',\n    'ReturnIntoArrayPop',\n    'ObjectSetFieldValue',\n    'ObjectCopyField',\n    'ObjectDeleteField',\n    'ArrayAppendValue',\n    'ArrayAppendSlice',\n    'StringAppendString',\n    'StringAppendSlice'\n];\nvar Patcher = /** @class */ (function () {\n    function Patcher(model, root, patch) {\n        this.i = 0;\n        this.inputStack = [];\n        this.outputStack = [];\n        this.model = model;\n        this.root = root;\n        this.patch = patch;\n    }\n    Patcher.prototype.read = function () {\n        return this.patch[this.i++];\n    };\n    Patcher.prototype.process = function () {\n        this.inputStack.push({ value: this.root });\n        this.outputStack.push({ value: this.root });\n        for (; this.i < this.patch.length;) {\n            var opcode = this.read();\n            var op = OPS[opcode];\n            if (!op)\n                throw new Error(\"Unknown opcode: \" + opcode);\n            var processor = \"process\" + op;\n            this[processor].apply(this);\n        }\n        var entry = this.outputStack.pop();\n        return this.finalizeOutput(entry);\n    };\n    Patcher.prototype.inputEntry = function () {\n        return this.inputStack[this.inputStack.length - 1];\n    };\n    Patcher.prototype.inputKey = function (entry, idx) {\n        if (!entry.keys) {\n            entry.keys = this.model.objectGetKeys(entry.value).sort();\n        }\n        return entry.keys[idx];\n    };\n    Patcher.prototype.outputEntry = function () {\n        return this.outputStack[this.outputStack.length - 1];\n    };\n    Patcher.prototype.outputArray = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyArray(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.outputObject = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyObject(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.outputString = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyString(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.finalizeOutput = function (entry) {\n        if (entry.writeValue) {\n            return this.model.finalize(entry.writeValue);\n        }\n        else {\n            return entry.value;\n        }\n    };\n    // Processors:\n    Patcher.prototype.processValue = function () {\n        var value = this.model.wrap(this.read());\n        this.outputStack.push({ value: value });\n    };\n    Patcher.prototype.processCopy = function () {\n        var input = this.inputEntry();\n        this.outputStack.push({ value: input.value });\n    };\n    Patcher.prototype.processBlank = function () {\n        this.outputStack.push({ value: null });\n    };\n    Patcher.prototype.processReturnIntoArray = function () {\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        var arr = this.outputArray();\n        this.model.arrayAppendValue(arr, result);\n    };\n    Patcher.prototype.processReturnIntoObject = function () {\n        var key = this.read();\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        result = this.model.markChanged(result);\n        var obj = this.outputObject();\n        this.model.objectSetField(obj, key, result);\n    };\n    Patcher.prototype.processReturnIntoObjectSameKey = function () {\n        var input = this.inputEntry();\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        var obj = this.outputObject();\n        this.model.objectSetField(obj, input.key, result);\n    };\n    Patcher.prototype.processPushField = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var key = this.inputKey(entry, idx);\n        var value = this.model.objectGetField(entry.value, key);\n        this.inputStack.push({ value: value, key: key });\n    };\n    Patcher.prototype.processPushElement = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var value = this.model.arrayGetElement(entry.value, idx);\n        this.inputStack.push({ value: value });\n    };\n    Patcher.prototype.processPop = function () {\n        this.inputStack.pop();\n    };\n    Patcher.prototype.processPushFieldCopy = function () {\n        this.processPushField();\n        this.processCopy();\n    };\n    Patcher.prototype.processPushFieldBlank = function () {\n        this.processPushField();\n        this.processBlank();\n    };\n    Patcher.prototype.processPushElementCopy = function () {\n        this.processPushElement();\n        this.processCopy();\n    };\n    Patcher.prototype.processPushElementBlank = function () {\n        this.processPushElement();\n        this.processBlank();\n    };\n    Patcher.prototype.processReturnIntoObjectPop = function () {\n        this.processReturnIntoObject();\n        this.processPop();\n    };\n    Patcher.prototype.processReturnIntoObjectSameKeyPop = function () {\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    };\n    Patcher.prototype.processReturnIntoArrayPop = function () {\n        this.processReturnIntoArray();\n        this.processPop();\n    };\n    Patcher.prototype.processObjectSetFieldValue = function () {\n        this.processValue();\n        this.processReturnIntoObject();\n    };\n    Patcher.prototype.processObjectCopyField = function () {\n        this.processPushField();\n        this.processCopy();\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    };\n    Patcher.prototype.processObjectDeleteField = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var key = this.inputKey(entry, idx);\n        var obj = this.outputObject();\n        this.model.objectDeleteField(obj, key);\n    };\n    Patcher.prototype.processArrayAppendValue = function () {\n        var value = this.model.wrap(this.read());\n        var arr = this.outputArray();\n        this.model.arrayAppendValue(arr, value);\n    };\n    Patcher.prototype.processArrayAppendSlice = function () {\n        var left = this.read();\n        var right = this.read();\n        var str = this.outputArray();\n        var val = this.inputEntry().value;\n        this.model.arrayAppendSlice(str, val, left, right);\n    };\n    Patcher.prototype.processStringAppendString = function () {\n        var value = this.model.wrap(this.read());\n        var str = this.outputString();\n        this.model.stringAppendValue(str, value);\n    };\n    Patcher.prototype.processStringAppendSlice = function () {\n        var left = this.read();\n        var right = this.read();\n        var str = this.outputString();\n        var val = this.inputEntry().value;\n        this.model.stringAppendSlice(str, val, left, right);\n    };\n    return Patcher;\n}());\n\n//# sourceMappingURL=internal-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9pbnRlcm5hbC1wYXRjaGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pELGdDQUFnQyxrQkFBa0I7QUFDbEQsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDa0I7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3Nhbml0eS1uZXh0bWVkaXVtL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vaW50ZXJuYWwtcGF0Y2hlci5qcz84YWY0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBPUFMgPSBbXG4gICAgJ1ZhbHVlJyxcbiAgICAnQ29weScsXG4gICAgJ0JsYW5rJyxcbiAgICAnUmV0dXJuSW50b0FycmF5JyxcbiAgICAnUmV0dXJuSW50b09iamVjdCcsXG4gICAgJ1JldHVybkludG9PYmplY3RTYW1lS2V5JyxcbiAgICAnUHVzaEZpZWxkJyxcbiAgICAnUHVzaEVsZW1lbnQnLFxuICAgICdQdXNoUGFyZW50JyxcbiAgICAnUG9wJyxcbiAgICAnUHVzaEZpZWxkQ29weScsXG4gICAgJ1B1c2hGaWVsZEJsYW5rJyxcbiAgICAnUHVzaEVsZW1lbnRDb3B5JyxcbiAgICAnUHVzaEVsZW1lbnRCbGFuaycsXG4gICAgJ1JldHVybkludG9PYmplY3RQb3AnLFxuICAgICdSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCcsXG4gICAgJ1JldHVybkludG9BcnJheVBvcCcsXG4gICAgJ09iamVjdFNldEZpZWxkVmFsdWUnLFxuICAgICdPYmplY3RDb3B5RmllbGQnLFxuICAgICdPYmplY3REZWxldGVGaWVsZCcsXG4gICAgJ0FycmF5QXBwZW5kVmFsdWUnLFxuICAgICdBcnJheUFwcGVuZFNsaWNlJyxcbiAgICAnU3RyaW5nQXBwZW5kU3RyaW5nJyxcbiAgICAnU3RyaW5nQXBwZW5kU2xpY2UnXG5dO1xudmFyIFBhdGNoZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGF0Y2hlcihtb2RlbCwgcm9vdCwgcGF0Y2gpIHtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLnBhdGNoID0gcGF0Y2g7XG4gICAgfVxuICAgIFBhdGNoZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGNoW3RoaXMuaSsrXTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWU6IHRoaXMucm9vdCB9KTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IHRoaXMucm9vdCB9KTtcbiAgICAgICAgZm9yICg7IHRoaXMuaSA8IHRoaXMucGF0Y2gubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIG9wY29kZSA9IHRoaXMucmVhZCgpO1xuICAgICAgICAgICAgdmFyIG9wID0gT1BTW29wY29kZV07XG4gICAgICAgICAgICBpZiAoIW9wKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3Bjb2RlOiBcIiArIG9wY29kZSk7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc29yID0gXCJwcm9jZXNzXCIgKyBvcDtcbiAgICAgICAgICAgIHRoaXNbcHJvY2Vzc29yXS5hcHBseSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5pbnB1dEVudHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dFN0YWNrW3RoaXMuaW5wdXRTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLmlucHV0S2V5ID0gZnVuY3Rpb24gKGVudHJ5LCBpZHgpIHtcbiAgICAgICAgaWYgKCFlbnRyeS5rZXlzKSB7XG4gICAgICAgICAgICBlbnRyeS5rZXlzID0gdGhpcy5tb2RlbC5vYmplY3RHZXRLZXlzKGVudHJ5LnZhbHVlKS5zb3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LmtleXNbaWR4XTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dEVudHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRTdGFja1t0aGlzLm91dHB1dFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcbiAgICAgICAgaWYgKCFlbnRyeS53cml0ZVZhbHVlKSB7XG4gICAgICAgICAgICBlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5QXJyYXkoZW50cnkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0T2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weU9iamVjdChlbnRyeS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5vdXRwdXRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcbiAgICAgICAgaWYgKCFlbnRyeS53cml0ZVZhbHVlKSB7XG4gICAgICAgICAgICBlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5U3RyaW5nKGVudHJ5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLmZpbmFsaXplT3V0cHV0ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS53cml0ZVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5maW5hbGl6ZShlbnRyeS53cml0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUHJvY2Vzc29yczpcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSk7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IGlucHV0LnZhbHVlIH0pO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc0JsYW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogbnVsbCB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgcmVzdWx0KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5tb2RlbC5tYXJrQ2hhbmdlZChyZXN1bHQpO1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5vYmplY3RTZXRGaWVsZChvYmosIGtleSwgcmVzdWx0KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMub3V0cHV0T2JqZWN0KCk7XG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBpbnB1dC5rZXksIHJlc3VsdCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5pbnB1dEtleShlbnRyeSwgaWR4KTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5vYmplY3RHZXRGaWVsZChlbnRyeS52YWx1ZSwga2V5KTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGtleToga2V5IH0pO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLmFycmF5R2V0RWxlbWVudChlbnRyeS52YWx1ZSwgaWR4KTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUgfSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucHV0U3RhY2sucG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEZpZWxkQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0NvcHkoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NQdXNoRmllbGRCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEVsZW1lbnRDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRWxlbWVudCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEVsZW1lbnRCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQmxhbmsoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0UG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5UG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXlQb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9BcnJheSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NPYmplY3RTZXRGaWVsZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NWYWx1ZSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0Q29weUZpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29weSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NPYmplY3REZWxldGVGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuaW5wdXRLZXkoZW50cnksIGlkeCk7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgICAgICB0aGlzLm1vZGVsLm9iamVjdERlbGV0ZUZpZWxkKG9iaiwga2V5KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NBcnJheUFwcGVuZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgICAgICB2YXIgYXJyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xuICAgICAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kVmFsdWUoYXJyLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQXJyYXlBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmlucHV0RW50cnkoKS52YWx1ZTtcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFNsaWNlKHN0ciwgdmFsLCBsZWZ0LCByaWdodCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nQXBwZW5kU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRTdHJpbmcoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdHJpbmdBcHBlbmRWYWx1ZShzdHIsIHZhbHVlKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NTdHJpbmdBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzLm91dHB1dFN0cmluZygpO1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XG4gICAgICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kU2xpY2Uoc3RyLCB2YWwsIGxlZnQsIHJpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBQYXRjaGVyO1xufSgpKTtcbmV4cG9ydCB7IFBhdGNoZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLXBhdGNoZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../sanity-nextmedium/node_modules/mendoza/lib/esm/internal-patcher.js\n");

/***/ }),

/***/ "../sanity-nextmedium/node_modules/mendoza/lib/esm/simple-patcher.js":
/*!***************************************************************************!*\
  !*** ../sanity-nextmedium/node_modules/mendoza/lib/esm/simple-patcher.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"../sanity-nextmedium/node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"../sanity-nextmedium/node_modules/mendoza/lib/esm/utf8.js\");\n\n\nvar Model = {\n    wrap: function (data) {\n        return data;\n    },\n    finalize: function (b) {\n        if (Array.isArray(b)) {\n            return b;\n        }\n        else {\n            return b.data;\n        }\n    },\n    markChanged: function (value) {\n        return value;\n    },\n    objectGetKeys: function (value) {\n        return Object.keys(value);\n    },\n    objectGetField: function (value, key) {\n        return value[key];\n    },\n    arrayGetElement: function (value, idx) {\n        return value[idx];\n    },\n    copyObject: function (value) {\n        var res = {\n            type: 'object',\n            data: {}\n        };\n        if (value !== null) {\n            for (var _i = 0, _a = Object.entries(value); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                res.data[key] = val;\n            }\n        }\n        return res;\n    },\n    copyArray: function (value) {\n        if (value === null)\n            return [];\n        return value.slice();\n    },\n    copyString: function (value) {\n        return {\n            type: 'string',\n            data: value === null ? '' : value\n        };\n    },\n    objectSetField: function (target, key, value) {\n        target.data[key] = value;\n    },\n    objectDeleteField: function (target, key) {\n        delete target.data[key];\n    },\n    arrayAppendValue: function (target, value) {\n        target.push(value);\n    },\n    arrayAppendSlice: function (target, source, left, right) {\n        target.push.apply(target, source.slice(left, right));\n    },\n    stringAppendSlice: function (target, source, left, right) {\n        var sourceString = source;\n        var leftPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, left);\n        var rightPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, right, leftPos);\n        target.data += sourceString.slice(leftPos, rightPos);\n    },\n    stringAppendValue: function (target, value) {\n        target.data += value;\n    }\n};\n// Applies a patch on a JavaScript object.\nfunction applyPatch(left, patch) {\n    var root = left; // No need to wrap because the representation is the same.\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(Model, root, patch);\n    return patcher.process();\n}\n//# sourceMappingURL=simple-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9zaW1wbGUtcGF0Y2hlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkM7QUFDSDtBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsdURBQWdCO0FBQ3RDLHVCQUF1Qix1REFBZ0I7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscUJBQXFCO0FBQ3JCLHNCQUFzQixzREFBTztBQUM3QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3Nhbml0eS1uZXh0bWVkaXVtL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vc2ltcGxlLXBhdGNoZXIuanM/YmYxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXRjaGVyIH0gZnJvbSAnLi9pbnRlcm5hbC1wYXRjaGVyJztcbmltcG9ydCB7IHV0ZjhyZXNvbHZlSW5kZXggfSBmcm9tICcuL3V0ZjgnO1xudmFyIE1vZGVsID0ge1xuICAgIHdyYXA6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiLmRhdGE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1hcmtDaGFuZ2VkOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgb2JqZWN0R2V0S2V5czogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgfSxcbiAgICBvYmplY3RHZXRGaWVsZDogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG4gICAgfSxcbiAgICBhcnJheUdldEVsZW1lbnQ6IGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVtpZHhdO1xuICAgIH0sXG4gICAgY29weU9iamVjdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIGtleSA9IF9iWzBdLCB2YWwgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICByZXMuZGF0YVtrZXldID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBjb3B5QXJyYXk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICAgIH0sXG4gICAgY29weVN0cmluZzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlID09PSBudWxsID8gJycgOiB2YWx1ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgb2JqZWN0U2V0RmllbGQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0LmRhdGFba2V5XSA9IHZhbHVlO1xuICAgIH0sXG4gICAgb2JqZWN0RGVsZXRlRmllbGQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0LmRhdGFba2V5XTtcbiAgICB9LFxuICAgIGFycmF5QXBwZW5kVmFsdWU6IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKHZhbHVlKTtcbiAgICB9LFxuICAgIGFycmF5QXBwZW5kU2xpY2U6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdGFyZ2V0LnB1c2guYXBwbHkodGFyZ2V0LCBzb3VyY2Uuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICB9LFxuICAgIHN0cmluZ0FwcGVuZFNsaWNlOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBzb3VyY2VTdHJpbmcgPSBzb3VyY2U7XG4gICAgICAgIHZhciBsZWZ0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIGxlZnQpO1xuICAgICAgICB2YXIgcmlnaHRQb3MgPSB1dGY4cmVzb2x2ZUluZGV4KHNvdXJjZVN0cmluZywgcmlnaHQsIGxlZnRQb3MpO1xuICAgICAgICB0YXJnZXQuZGF0YSArPSBzb3VyY2VTdHJpbmcuc2xpY2UobGVmdFBvcywgcmlnaHRQb3MpO1xuICAgIH0sXG4gICAgc3RyaW5nQXBwZW5kVmFsdWU6IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldC5kYXRhICs9IHZhbHVlO1xuICAgIH1cbn07XG4vLyBBcHBsaWVzIGEgcGF0Y2ggb24gYSBKYXZhU2NyaXB0IG9iamVjdC5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGxlZnQsIHBhdGNoKSB7XG4gICAgdmFyIHJvb3QgPSBsZWZ0OyAvLyBObyBuZWVkIHRvIHdyYXAgYmVjYXVzZSB0aGUgcmVwcmVzZW50YXRpb24gaXMgdGhlIHNhbWUuXG4gICAgdmFyIHBhdGNoZXIgPSBuZXcgUGF0Y2hlcihNb2RlbCwgcm9vdCwgcGF0Y2gpO1xuICAgIHJldHVybiBwYXRjaGVyLnByb2Nlc3MoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZS1wYXRjaGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../sanity-nextmedium/node_modules/mendoza/lib/esm/simple-patcher.js\n");

/***/ }),

/***/ "../sanity-nextmedium/node_modules/mendoza/lib/esm/utf8.js":
/*!*****************************************************************!*\
  !*** ../sanity-nextmedium/node_modules/mendoza/lib/esm/utf8.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"utf8charSize\": function() { return /* binding */ utf8charSize; },\n/* harmony export */   \"utf8stringSize\": function() { return /* binding */ utf8stringSize; },\n/* harmony export */   \"utf8resolveIndex\": function() { return /* binding */ utf8resolveIndex; },\n/* harmony export */   \"commonPrefix\": function() { return /* binding */ commonPrefix; },\n/* harmony export */   \"commonSuffix\": function() { return /* binding */ commonSuffix; }\n/* harmony export */ });\nfunction utf8charSize(code) {\n    if (code >> 16) {\n        return 4;\n    }\n    else if (code >> 11) {\n        return 3;\n    }\n    else if (code >> 7) {\n        return 2;\n    }\n    else {\n        return 1;\n    }\n}\nfunction utf8stringSize(str) {\n    var b = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code = str.codePointAt(i);\n        var size = utf8charSize(code);\n        if (size == 4)\n            i++;\n        b += size;\n    }\n    return b;\n}\n/** Converts an UTF-8 byte index into a UCS-2 index. */\nfunction utf8resolveIndex(str, idx, start) {\n    if (start === void 0) { start = 0; }\n    var byteCount = start;\n    var ucsIdx = 0;\n    for (ucsIdx = start; byteCount < idx; ucsIdx++) {\n        var code = str.codePointAt(ucsIdx);\n        var size = utf8charSize(code);\n        if (size === 4)\n            ucsIdx++; // Surrogate pair.\n        byteCount += size;\n    }\n    return ucsIdx;\n}\nfunction commonPrefix(str, str2) {\n    var len = Math.min(str.length, str2.length);\n    var b = 0;\n    for (var i = 0; i < len;) {\n        var aPoint = str.codePointAt(i);\n        var bPoint = str2.codePointAt(i);\n        if (aPoint !== bPoint)\n            return b;\n        var size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\nfunction commonSuffix(str, str2, prefix) {\n    if (prefix === void 0) { prefix = 0; }\n    var len = Math.min(str.length, str2.length) - prefix;\n    var b = 0;\n    for (var i = 0; i < len;) {\n        var aPoint = str.codePointAt(str.length - 1 - i);\n        var bPoint = str2.codePointAt(str2.length - 1 - i);\n        if (aPoint !== bPoint)\n            return b;\n        var size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS91dGY4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3Nhbml0eS1uZXh0bWVkaXVtL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vdXRmOC5qcz8yYWM3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiB1dGY4Y2hhclNpemUoY29kZSkge1xuICAgIGlmIChjb2RlID4+IDE2KSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID4+IDExKSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID4+IDcpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdXRmOHN0cmluZ1NpemUoc3RyKSB7XG4gICAgdmFyIGIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICAgICAgaWYgKHNpemUgPT0gNClcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgYiArPSBzaXplO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbi8qKiBDb252ZXJ0cyBhbiBVVEYtOCBieXRlIGluZGV4IGludG8gYSBVQ1MtMiBpbmRleC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4cmVzb2x2ZUluZGV4KHN0ciwgaWR4LCBzdGFydCkge1xuICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gMDsgfVxuICAgIHZhciBieXRlQ291bnQgPSBzdGFydDtcbiAgICB2YXIgdWNzSWR4ID0gMDtcbiAgICBmb3IgKHVjc0lkeCA9IHN0YXJ0OyBieXRlQ291bnQgPCBpZHg7IHVjc0lkeCsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNvZGVQb2ludEF0KHVjc0lkeCk7XG4gICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gNClcbiAgICAgICAgICAgIHVjc0lkeCsrOyAvLyBTdXJyb2dhdGUgcGFpci5cbiAgICAgICAgYnl0ZUNvdW50ICs9IHNpemU7XG4gICAgfVxuICAgIHJldHVybiB1Y3NJZHg7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tbW9uUHJlZml4KHN0ciwgc3RyMikge1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBzdHIyLmxlbmd0aCk7XG4gICAgdmFyIGIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICB2YXIgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgICB2YXIgYlBvaW50ID0gc3RyMi5jb2RlUG9pbnRBdChpKTtcbiAgICAgICAgaWYgKGFQb2ludCAhPT0gYlBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGFQb2ludCk7XG4gICAgICAgIGIgKz0gc2l6ZTtcbiAgICAgICAgaSArPSBzaXplID09PSA0ID8gMiA6IDE7XG4gICAgfVxuICAgIHJldHVybiBiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblN1ZmZpeChzdHIsIHN0cjIsIHByZWZpeCkge1xuICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgeyBwcmVmaXggPSAwOyB9XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIHN0cjIubGVuZ3RoKSAtIHByZWZpeDtcbiAgICB2YXIgYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIHZhciBhUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoc3RyLmxlbmd0aCAtIDEgLSBpKTtcbiAgICAgICAgdmFyIGJQb2ludCA9IHN0cjIuY29kZVBvaW50QXQoc3RyMi5sZW5ndGggLSAxIC0gaSk7XG4gICAgICAgIGlmIChhUG9pbnQgIT09IGJQb2ludClcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShhUG9pbnQpO1xuICAgICAgICBiICs9IHNpemU7XG4gICAgICAgIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../sanity-nextmedium/node_modules/mendoza/lib/esm/utf8.js\n");

/***/ }),

/***/ "../sanity-nextmedium/node_modules/throttle-debounce/cjs/index.js":
/*!************************************************************************!*\
  !*** ../sanity-nextmedium/node_modules/throttle-debounce/cjs/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset).\n * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function}  A new, throttled, function.\n */\nfunction throttle (delay, noTrailing, callback, debounceMode) {\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel() {\n    clearExistingTimeout();\n    cancelled = true;\n  } // `noTrailing` defaults to falsy.\n\n\n  if (typeof noTrailing !== 'boolean') {\n    debounceMode = callback;\n    callback = noTrailing;\n    noTrailing = undefined;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      /*\n       * In throttle mode, if `delay` time has been exceeded, execute\n       * `callback`.\n       */\n      exec();\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                  to `callback` when the debounced-function is executed.\n *\n * @returns {Function} A new, debounced function.\n */\n\nfunction debounce (delay, atBegin, callback) {\n  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);\n}\n\nexports.debounce = debounce;\nexports.throttle = throttle;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2FuaXR5LW5leHRtZWRpdW0vbm9kZV9tb2R1bGVzL3Rocm90dGxlLWRlYm91bmNlL2Nqcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QixvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsOEVBQThFLGFBQWE7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9zYW5pdHktbmV4dG1lZGl1bS9ub2RlX21vZHVsZXMvdGhyb3R0bGUtZGVib3VuY2UvY2pzL2luZGV4LmpzPzFkYTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQsbm8tcGFyYW0tcmVhc3NpZ24sbm8tc2hhZG93ICovXG5cbi8qKlxuICogVGhyb3R0bGUgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uIEVzcGVjaWFsbHkgdXNlZnVsIGZvciByYXRlIGxpbWl0aW5nXG4gKiBleGVjdXRpb24gb2YgaGFuZGxlcnMgb24gZXZlbnRzIGxpa2UgcmVzaXplIGFuZCBzY3JvbGwuXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSAgICBkZWxheSAtICAgICAgICAgIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50IGNhbGxiYWNrcywgdmFsdWVzIGFyb3VuZCAxMDAgb3IgMjUwIChvciBldmVuIGhpZ2hlcikgYXJlIG1vc3QgdXNlZnVsLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gICBbbm9UcmFpbGluZ10gLSAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgbm9UcmFpbGluZyBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIG9ubHkgZXhlY3V0ZSBldmVyeSBgZGVsYXlgIG1pbGxpc2Vjb25kcyB3aGlsZSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGVkLWZ1bmN0aW9uIGlzIGJlaW5nIGNhbGxlZC4gSWYgbm9UcmFpbGluZyBpcyBmYWxzZSBvciB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbmUgZmluYWwgdGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgbGFzdCB0aHJvdHRsZWQtZnVuY3Rpb24gY2FsbC4gKEFmdGVyIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KS5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgLSAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGBjYWxsYmFja2Agd2hlbiB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gICBbZGVib3VuY2VNb2RlXSAtIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgc2NoZWR1bGUgYGNsZWFyYCB0byBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuIElmIGBkZWJvdW5jZU1vZGVgIGlzIGZhbHNlIChhdCBlbmQpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259ICBBIG5ldywgdGhyb3R0bGVkLCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUgKGRlbGF5LCBub1RyYWlsaW5nLCBjYWxsYmFjaywgZGVib3VuY2VNb2RlKSB7XG4gIC8qXG4gICAqIEFmdGVyIHdyYXBwZXIgaGFzIHN0b3BwZWQgYmVpbmcgY2FsbGVkLCB0aGlzIHRpbWVvdXQgZW5zdXJlcyB0aGF0XG4gICAqIGBjYWxsYmFja2AgaXMgZXhlY3V0ZWQgYXQgdGhlIHByb3BlciB0aW1lcyBpbiBgdGhyb3R0bGVgIGFuZCBgZW5kYFxuICAgKiBkZWJvdW5jZSBtb2Rlcy5cbiAgICovXG4gIHZhciB0aW1lb3V0SUQ7XG4gIHZhciBjYW5jZWxsZWQgPSBmYWxzZTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB0aW1lIGBjYWxsYmFja2Agd2FzIGV4ZWN1dGVkLlxuXG4gIHZhciBsYXN0RXhlYyA9IDA7IC8vIEZ1bmN0aW9uIHRvIGNsZWFyIGV4aXN0aW5nIHRpbWVvdXRcblxuICBmdW5jdGlvbiBjbGVhckV4aXN0aW5nVGltZW91dCgpIHtcbiAgICBpZiAodGltZW91dElEKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICB9XG4gIH0gLy8gRnVuY3Rpb24gdG8gY2FuY2VsIG5leHQgZXhlY1xuXG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCk7XG4gICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgfSAvLyBgbm9UcmFpbGluZ2AgZGVmYXVsdHMgdG8gZmFsc3kuXG5cblxuICBpZiAodHlwZW9mIG5vVHJhaWxpbmcgIT09ICdib29sZWFuJykge1xuICAgIGRlYm91bmNlTW9kZSA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gbm9UcmFpbGluZztcbiAgICBub1RyYWlsaW5nID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qXG4gICAqIFRoZSBgd3JhcHBlcmAgZnVuY3Rpb24gZW5jYXBzdWxhdGVzIGFsbCBvZiB0aGUgdGhyb3R0bGluZyAvIGRlYm91bmNpbmdcbiAgICogZnVuY3Rpb25hbGl0eSBhbmQgd2hlbiBleGVjdXRlZCB3aWxsIGxpbWl0IHRoZSByYXRlIGF0IHdoaWNoIGBjYWxsYmFja2BcbiAgICogaXMgZXhlY3V0ZWQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzXyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3VtZW50c19bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGxhc3RFeGVjO1xuXG4gICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRXhlY3V0ZSBgY2FsbGJhY2tgIGFuZCB1cGRhdGUgdGhlIGBsYXN0RXhlY2AgdGltZXN0YW1wLlxuXG5cbiAgICBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgbGFzdEV4ZWMgPSBEYXRlLm5vdygpO1xuICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJndW1lbnRzXyk7XG4gICAgfVxuICAgIC8qXG4gICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pIHRoaXMgaXMgdXNlZCB0byBjbGVhciB0aGUgZmxhZ1xuICAgICAqIHRvIGFsbG93IGZ1dHVyZSBgY2FsbGJhY2tgIGV4ZWN1dGlvbnMuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGltZW91dElEID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChkZWJvdW5jZU1vZGUgJiYgIXRpbWVvdXRJRCkge1xuICAgICAgLypcbiAgICAgICAqIFNpbmNlIGB3cmFwcGVyYCBpcyBiZWluZyBjYWxsZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZFxuICAgICAgICogYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBleGVjdXRlIGBjYWxsYmFja2AuXG4gICAgICAgKi9cbiAgICAgIGV4ZWMoKTtcbiAgICB9XG5cbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuXG4gICAgaWYgKGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkICYmIGVsYXBzZWQgPiBkZWxheSkge1xuICAgICAgLypcbiAgICAgICAqIEluIHRocm90dGxlIG1vZGUsIGlmIGBkZWxheWAgdGltZSBoYXMgYmVlbiBleGNlZWRlZCwgZXhlY3V0ZVxuICAgICAgICogYGNhbGxiYWNrYC5cbiAgICAgICAqL1xuICAgICAgZXhlYygpO1xuICAgIH0gZWxzZSBpZiAobm9UcmFpbGluZyAhPT0gdHJ1ZSkge1xuICAgICAgLypcbiAgICAgICAqIEluIHRyYWlsaW5nIHRocm90dGxlIG1vZGUsIHNpbmNlIGBkZWxheWAgdGltZSBoYXMgbm90IGJlZW5cbiAgICAgICAqIGV4Y2VlZGVkLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYGRlbGF5YCBtcyBhZnRlciBtb3N0XG4gICAgICAgKiByZWNlbnQgZXhlY3V0aW9uLlxuICAgICAgICpcbiAgICAgICAqIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgc2NoZWR1bGUgYGNsZWFyYCB0byBleGVjdXRlXG4gICAgICAgKiBhZnRlciBgZGVsYXlgIG1zLlxuICAgICAgICpcbiAgICAgICAqIElmIGBkZWJvdW5jZU1vZGVgIGlzIGZhbHNlIChhdCBlbmQpLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvXG4gICAgICAgKiBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuXG4gICAgICAgKi9cbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZGVib3VuY2VNb2RlID8gY2xlYXIgOiBleGVjLCBkZWJvdW5jZU1vZGUgPT09IHVuZGVmaW5lZCA/IGRlbGF5IC0gZWxhcHNlZCA6IGRlbGF5KTtcbiAgICB9XG4gIH1cblxuICB3cmFwcGVyLmNhbmNlbCA9IGNhbmNlbDsgLy8gUmV0dXJuIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuXG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQgKi9cbi8qKlxuICogRGVib3VuY2UgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uIERlYm91bmNpbmcsIHVubGlrZSB0aHJvdHRsaW5nLFxuICogZ3VhcmFudGVlcyB0aGF0IGEgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBhIHNpbmdsZSB0aW1lLCBlaXRoZXIgYXQgdGhlXG4gKiB2ZXJ5IGJlZ2lubmluZyBvZiBhIHNlcmllcyBvZiBjYWxscywgb3IgYXQgdGhlIHZlcnkgZW5kLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gICBkZWxheSAtICAgICAgICAgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnQgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKSBhcmUgbW9zdCB1c2VmdWwuXG4gKiBAcGFyYW0gIHtib29sZWFufSAgW2F0QmVnaW5dIC0gICAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgYXRCZWdpbiBpcyBmYWxzZSBvciB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGBkZWxheWAgbWlsbGlzZWNvbmRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgbGFzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC4gSWYgYXRCZWdpbiBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9ubHkgYXQgdGhlIGZpcnN0IGRlYm91bmNlZC1mdW5jdGlvbiBjYWxsLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEFmdGVyIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KS5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtICAgICAgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkZWxheSBtaWxsaXNlY29uZHMuIFRoZSBgdGhpc2AgY29udGV4dCBhbmQgYWxsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRocm91Z2gsIGFzLWlzLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYGNhbGxiYWNrYCB3aGVuIHRoZSBkZWJvdW5jZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldywgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGRlYm91bmNlIChkZWxheSwgYXRCZWdpbiwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyB0aHJvdHRsZShkZWxheSwgYXRCZWdpbiwgZmFsc2UpIDogdGhyb3R0bGUoZGVsYXksIGNhbGxiYWNrLCBhdEJlZ2luICE9PSBmYWxzZSk7XG59XG5cbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../sanity-nextmedium/node_modules/throttle-debounce/cjs/index.js\n");

/***/ })

}]);